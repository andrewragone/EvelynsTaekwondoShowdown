<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Evelyn’s Taekwondo Showdown</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 3px;
            display: none; /* Hidden by default, shown in gameplay */
            z-index: 10; /* Ensure it's above canvas */
        }
        /* Add styles for HTML health bars */
        .health-bar {
            position: fixed;
            top: 10px;
            width: 200px;
            height: 20px;
            border: 2px solid #fff;
            background-color: #333;
            z-index: 10;
            display: none; /* Hidden by default, shown in gameplay */
            overflow: hidden; /* Ensure the fill doesn't overflow */
            border-radius: 5px; /* Rounded corners */
        }
        #player-health-bar {
            left: 10px;
        }
        #opponent-health-bar {
            right: 10px;
        }
        .health-bar-fill {
            width: 100%;
            height: 100%;
            background-color: #f00;
        }
        #player-health-bar-fill {
            transform-origin: right center;
        }
        #opponent-health-bar-fill {
            transform-origin: left center;
        }
        
        /* Mobile control buttons */
        .mobile-control {
            position: fixed;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5);
            border: 3px solid rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #000;
            user-select: none;
            -webkit-user-select: none;
            z-index: 1000;
            touch-action: manipulation;
        }
        
        /* Left side controls */
        #btn-left {
            bottom: 20px;
            left: 20px;
        }
        #btn-right {
            bottom: 20px;
            left: 90px;
        }
        #btn-jump {
            bottom: 90px;
            left: 55px;
        }
        
        /* Right side controls */
        #btn-punch {
            bottom: 20px;
            right: 20px;
        }
        #btn-kick {
            bottom: 20px;
            right: 90px;
        }
        #btn-block {
            bottom: 20px;
            right: 160px;
        }
    </style>
</head>
<body>
    <div id="instructions">
        Desktop: Arrow Keys (Move/Jump), X (Punch), C (Kick), Z (Block)<br>
        Mobile: Left side - movement arrows, Right side - attack buttons (P=Punch, K=Kick, B=Block)
    </div>
    <div id="player-health-bar" class="health-bar">
        <div id="player-health-bar-fill" class="health-bar-fill"></div>
    </div>
    <div id="opponent-health-bar" class="health-bar">
        <div id="opponent-health-bar-fill" class="health-bar-fill"></div>
    </div>
    
    <!-- Mobile Controls -->
    <div id="mobile-controls" style="display: none;">
        <!-- Left side controls -->
        <div id="btn-left" class="mobile-control">←</div>
        <div id="btn-right" class="mobile-control">→</div>
        <div id="btn-jump" class="mobile-control">↑</div>
        
        <!-- Right side controls -->
        <div id="btn-punch" class="mobile-control">P</div>
        <div id="btn-kick" class="mobile-control">K</div>
        <div id="btn-block" class="mobile-control">B</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // --- Configuration ---
        const CONFIG = {
            CAMERA_POS: new THREE.Vector3(0, 2.4, 10), // Moved camera farther back to reduce perspective distortion
            CHARACTER: {
                bodyRadius: 0.5, bodyHeight: 1.88,
                headRadius: 0.375,
                shoulderWidth: 0.875,
                armUpperLength: 0.75, armLowerLength: 0.625, armRadius: 0.19,
                legUpperLength: 0.875, legLowerLength: 0.875, legRadius: 0.225,
                beltSize: new THREE.Vector3(1.125, 0.19, 0.56),
                skinColor: 0xf5d7b2,
                giColor: 0xffffff,
                opponentGiColor: 0xff0000,
                beltColor: 0x000000,
                jointColor: 0x333333,
            },
            ARENA: {
                width: 8, // Reduced from 10 to make the dojo skinnier
                floorColor: 0xd3d3d3,
                playerStartX: -2, // Player on left side
                opponentStartX: 2, // Opponent on right side
                boundaryLeft: -3, // Narrower boundaries
                boundaryRight: 3, // Narrower boundaries
            },
            MOVEMENT: {
                speed: 0.15, // Increased from 0.05 to make movement faster
                jumpVelocity: 0.12, // Increased from 0.08 for higher jumps
                gravity: 0.0035, // Slightly reduced for better jump arc
                maxJumpHeight: 2.0, // Increased maximum jump height
            },
            ATTACK: {
                punchReach: 1.6, punchDamage: 1, punchDuration: 300,
                kickReach: 3.0, kickDamage: 2, kickDuration: 500, // Increased reach to allow kicks to connect at safe distance
                cooldown: 0, // Reduced cooldown for more responsive attacks
            },
            AI: {
                moveIntervalMin: 1000, moveIntervalMax: 2000,
                attackIntervalMin: 1500, attackIntervalMax: 3000,
                attackProbability: 0.7,
            },
            HEALTH: {
                max: 100,
                barWidth: 2, barHeight: 0.2, barOffset: 2.5, // Increased from 1.8 to position above heads
                barColor: 0xff0000,
                barBackgroundColor: 0x333333, // Added background color for better visibility
            },
            UI: {
                font: 'bold 32px Arial',
                fontColor: 'white',
                outlineColor: 'black',
                buttonWidth: 1.5, buttonHeight: 0.5,
                mobileButtonSize: 1.0, // Increased from 0.8 for better touch targets
                mobileButtonOpacity: 0.9, // Increased from 0.7 for better visibility
            },
            COLORS: {
                introBg: 0x87ceeb,
                gameBg: 0x00008b,
                endBg: 0x800080,
                startButton: 0xff0000,
                playAgainButton: 0x00ff00,
                mobileLeftRight: 0x808080,
                mobileJump: 0xffff00,
                mobilePunch: 0xff0000,
                mobileKick: 0xff6600,
            },
            ANIMATION: {
                textFadeTime: 1000,
                introHoldTime: 3000,
                introKickSpeed: 0.015,
                victoryPoseSpeed: 0.01,
                kickLegUpperRotation: Math.PI / 3,  // Upper leg rotation for kick
                kickLegLowerRotation: -Math.PI / 2, // Lower leg rotation for kick
                punchArmRotation: -Math.PI / 2.5    // Arm rotation for punch
            },
            CONFETTI: {
                count: 50,
                fallSpeed: 0.05,
                spawnY: 5,
                despawnY: -1,
                colors: [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff],
            }
        };

        // --- Global Variables ---
        let scene, camera, renderer, clock;
        // Consistent ground height for all character logic
        const GROUND_Y = CONFIG.CHARACTER.legLowerLength / 2 - 1;
        let gameState = 'loading'; // loading, intro, gameplay, ending
        let player, opponent;
        let floor;
        let backgroundMusic; // Audio element for background music
        let texturePixelData = {}; // Store pixel data for collision detection
        let introText, startButton, endText, playAgainButton, confetti = [];
        let playerHealthBar, opponentHealthBar;
        let mobileButtons = {};
        let keysPressed = {}; // Store pressed keys/buttons
        let activeMobileInputs = {}; // Track active pointer IDs for mobile buttons
        let backgroundSprite; // New global variable for background sprite
        let gameStarted = false;
        let playerWon = false; // Flag to track if player won the last round

        // Initial player/opponent states
        const initialPlayerState = { jumping: false, velocityY: 0, attacking: false, attackType: 'punch', attackTimer: 0, lastAttackTime: 0, health: CONFIG.HEALTH.max, id: 'player', position: { x: -2 }, blocking: false };
        const initialOpponentState = { 
            attacking: false, 
            attackType: 'punch', 
            attackTimer: 0, 
            moveDirection: 1, 
            nextMoveTime: 0, 
            nextAttackTime: 0, 
            nextJumpTime: 0,
            jumping: false,
            velocityY: 0,
            health: CONFIG.HEALTH.max, 
            id: 'opponent', 
            position: { x: 2 } 
        };

        let raycaster, pointer;

        // Define screen boundaries (adjust these values based on your dojo.jpg dimensions)
        const SCREEN_LEFT = -5;  // Left edge of visible area
        const SCREEN_RIGHT = 5;  // Right edge of visible area
        const CHARACTER_HALF_WIDTH = 1; // Half of character width (since scale.x=2)

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); // Reduced FOV from 75 to 45 for less distortion
            camera.position.copy(CONFIG.CAMERA_POS);
            camera.lookAt(0, 0.7, 0); // Looking at the same point, but with less perspective distortion

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();
            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();
            
            // Initialize audio
            initAudio();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            // Mobile / Pointer Events
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointerup', onPointerUp);
            renderer.domElement.addEventListener('pointermove', onPointerMove); // Needed to track movement off buttons
            renderer.domElement.addEventListener('pointerleave', onPointerLeave); // Handle pointer leaving canvas

            createMobileControls();
            setupSceneLighting();

            gameState = 'intro';
            setupIntro();

            animate();
        }

        function setupSceneLighting() {
            if (!backgroundSprite) {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load('assets/images/dojo.jpg', 
                    (texture) => {
                        console.log('Background texture loaded successfully');
                        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                        backgroundSprite = new THREE.Sprite(spriteMaterial);
                        backgroundSprite.position.z = -15; // Move back further to accommodate zoom
                        scene.add(backgroundSprite);
                        // Scale to fill camera view
                        scaleSpriteToCamera(backgroundSprite, camera, 1.0);
                    },
                    undefined,
                    (err) => console.error('Error loading background texture:', err)
                );
            } else {
                scene.add(backgroundSprite);
            }

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
        }

        // Utility: Scale a sprite to fill the camera view (no black bars)
        function scaleSpriteToCamera(sprite, camera, zoomFactor = 1) {
            if (!sprite || !camera) return;
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const distance = Math.abs(camera.position.z - (sprite.position.z || 0));
            const height = 2 * Math.tan(vFOV / 2) * distance;
            const width = height * camera.aspect;
            const tex = sprite.material.map;
            if (tex && tex.image) {
                const imgAspect = tex.image.width / tex.image.height;
                let spriteW = width * zoomFactor;
                let spriteH = height * zoomFactor;
                // Fit to cover (no black bars)
                if (spriteW / spriteH > imgAspect) {
                    spriteH = spriteW / imgAspect;
                } else {
                    spriteW = spriteH * imgAspect;
                }
                sprite.scale.set(spriteW, spriteH, 1);
            } else {
                sprite.scale.set(width * zoomFactor, height * zoomFactor, 1);
            }
        }

        // --- State Management & Scene Setup ---
        function clearScene() {
            if (introText) scene.remove(introText);
            if (startButton) scene.remove(startButton);
            if (endText) scene.remove(endText);
            if (playAgainButton) scene.remove(playAgainButton);
            if (floor) scene.remove(floor);
            if (player) scene.remove(player);
            if (opponent) scene.remove(opponent);
            
            // Properly clear all confetti
            confetti.forEach(confetto => {
                scene.remove(confetto);
                // Also dispose of geometries and materials to prevent memory leaks
                if (confetto.geometry) confetto.geometry.dispose();
                if (confetto.material) confetto.material.dispose();
            });
            confetti = [];
            
            // Look for and remove any confetti group
            const confettiGroup = scene.getObjectByName('confettiGroup');
            if (confettiGroup) {
                scene.remove(confettiGroup);
            }
            
            // Don't remove backgroundSprite
            Object.values(mobileButtons).forEach(btn => { btn.visible = false; });
        }

        function setupIntro() {
            clearScene();
            
            // Hide health bars
            document.getElementById('player-health-bar').style.display = 'none';
            document.getElementById('opponent-health-bar').style.display = 'none';
            
            // No intro music, only gameplay music
            
            gameState = 'intro';
            Object.values(mobileButtons).forEach(btn => { btn.visible = false; });

            // Create temporary character with startgame image
            const tempTextureLoader = new THREE.TextureLoader();
            const startgameTexture = tempTextureLoader.load('assets/images/evelyn-startgame.png');
            const introMaterial = new THREE.MeshBasicMaterial({
                map: startgameTexture,
                transparent: true,
                side: THREE.DoubleSide
            });
            const aspectRatio = 2014/2097; // Original image aspect ratio
            const height = 7; // Slightly smaller height for better fit
            const introCharacter = new THREE.Mesh(
                new THREE.PlaneGeometry(height * aspectRatio, height),
                introMaterial
            );
            introCharacter.position.set(0, 0.5, 0);
            introCharacter.scale.set(1.15, 1.15, 1.15);
            scene.add(introCharacter);
            
            const introLines = [
                "Evelyn's Taekwondo",  "Showdown:",
                "8th Birthday Party", "Edition", "",
                "Get ready to kick it at ",
                "UMAC Briarcliff!"
            ];
            introText = createTextMesh(introLines.join('\n'), { x: 0, y: 1.5, z: 0 }, 0.8, true); // Lowered y to match introCharacter
            introText.material.opacity = 1; // Changed from 0 to 1 to make visible
            scene.add(introText);

            // Create a clickable HTML button instead of a 3D button
            const startButtonHTML = document.createElement('button');
            startButtonHTML.id = 'startFightButton'; // Add ID for easier selection
            startButtonHTML.textContent = 'Start Fight';
            startButtonHTML.style.position = 'absolute';
            startButtonHTML.style.left = '50%';
            startButtonHTML.style.top = '70%';
            startButtonHTML.style.transform = 'translate(-50%, -50%)';
            startButtonHTML.style.padding = '15px 30px';
            startButtonHTML.style.fontSize = '24px';
            startButtonHTML.style.backgroundColor = '#ff0000';
            startButtonHTML.style.color = 'white';
            startButtonHTML.style.border = 'none';
            startButtonHTML.style.borderRadius = '5px';
            startButtonHTML.style.cursor = 'pointer';
            startButtonHTML.style.fontFamily = 'Arial, sans-serif';
            startButtonHTML.style.fontWeight = 'bold';
            startButtonHTML.style.zIndex = '1000';
            startButtonHTML.onclick = function() {
                
                // Remove the button immediately when clicked
                if (startButtonHTML.parentNode) {
                    startButtonHTML.parentNode.removeChild(startButtonHTML);
                }
                startGameplay();
            };

            document.body.appendChild(startButtonHTML);
            
            // Store reference to remove it later
            startButton = startButtonHTML;

            introCharacter.userData.introFadeInTimer = clock.getElapsedTime() + 0.1;
            introCharacter.userData.introHoldTimer = 0;
            introCharacter.userData.introFadeOutTimer = 0;
        }

        function startGameplay() {
            // Remove any existing ending images or end sprite when restarting
            document.querySelectorAll('.ending-image').forEach(img => img.remove());
            const oldEndSprite = scene.getObjectByName('endSprite');
            if (oldEndSprite) scene.remove(oldEndSprite);
            
            // Remove intro screen mesh and text
            scene.children.forEach(child => {
                if (child.userData && child.userData.introFadeInTimer !== undefined) {
                    scene.remove(child);
                }
            });
            if (introText) {
                scene.remove(introText);
                introText = null;
            }
            clearScene();
            
            // Hide health bars
            document.getElementById('player-health-bar').style.display = 'none';
            document.getElementById('opponent-health-bar').style.display = 'none';
            
            gameState = 'gameplay';
            
            // Reset game clock to ensure consistent timing for AI decisions
            clock = new THREE.Clock();
            
            // Check if on mobile device before showing instructions
            const isMobileDevice = ('ontouchstart' in window) || 
                                  (navigator.maxTouchPoints > 0) || 
                                  /Android|iPhone|iPad|iPod|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Only show instructions on desktop
            if (!isMobileDevice) {
                document.getElementById('instructions').style.display = 'block';
            } else {
                document.getElementById('instructions').style.display = 'none';
            }
            
            document.getElementById('mobile-controls').style.display = 'block'; // Show mobile controls
            
            // Start background music
            playBackgroundMusic();

            player = createCharacter(CONFIG.CHARACTER.giColor, false, false); // Player has no belt
            player.userData.originalColor = new THREE.Color(1, 1, 1); // Store original color for hit effect
            
            // Use the calculated ground level for initial position - player on left
            player.position.set(CONFIG.ARENA.playerStartX, CONFIG.CHARACTER.legLowerLength / 2 - 1, 0);
            player.scale.set(1.05, 1.05, 1.05);
            
            // Preserve the limb references by merging the initial state into the existing userData
            Object.assign(player.userData, initialPlayerState);
            
            scene.add(player);

            opponent = createCharacter(CONFIG.CHARACTER.opponentGiColor, true, true); // Opponent has belt and is flipped
            
            // Use the calculated ground level for initial position - opponent on right
            opponent.position.set(CONFIG.ARENA.opponentStartX, CONFIG.CHARACTER.legLowerLength / 2 - 1, 0);
            opponent.scale.set(1.05, 1.05, 1.05);
            
            // Preserve the limb references by merging the initial state into the existing userData
            Object.assign(opponent.userData, initialOpponentState);
            
            // Set initial AI timing values
            const now = clock.getElapsedTime();
            opponent.userData.nextMoveTime = now + Math.random() * (CONFIG.AI.moveIntervalMax - CONFIG.AI.moveIntervalMin) / 1000 + CONFIG.AI.moveIntervalMin / 1000;
            opponent.userData.nextAttackTime = now + Math.random() * (CONFIG.AI.attackIntervalMax - CONFIG.AI.attackIntervalMin) / 1000 + CONFIG.AI.attackIntervalMin / 1000;
            opponent.userData.nextJumpTime = now + 1 + Math.random() * 2; // First jump decision in 1-3 seconds
            
            scene.add(opponent);

            // Create HTML-based health bars instead of Three.js objects
            createHTMLHealthBars();

            keysPressed = {};
            activeMobileInputs = {};
            Object.values(mobileButtons).forEach(btn => { btn.visible = true; });
            positionMobileControls();
        }

        function setupEnding() {
            // Remove any existing ending images
            document.querySelectorAll('.ending-image').forEach(img => img.remove());
            
            clearScene();
            
            // Hide health bars
            document.getElementById('player-health-bar').style.display = 'none';
            document.getElementById('opponent-health-bar').style.display = 'none';
            
            // Stop background music
            stopBackgroundMusic();
            // Remove any existing HTML buttons
            const startFightButton = document.getElementById('startFightButton');
            if (startFightButton) {
                startFightButton.parentNode.removeChild(startFightButton);
            }
            const existingPlayAgainButton = document.getElementById('playAgainButton');
            if (existingPlayAgainButton) {
                existingPlayAgainButton.parentNode.removeChild(existingPlayAgainButton);
            }
            
            gameState = 'ending';
            Object.values(mobileButtons).forEach(btn => { btn.visible = false; });

            // Choose end text based on win/loss
            let endLines;
            if (playerWon) {
                endLines = [
                    "Victory!", "To Be Continued at", "Evelyn's Birthday Party!",
                     "",
                    "Join us at ", "UMAC Briarcliff", "528 N State Rd",
                    "Briarcliff Manor, NY 10510",
                    "April 26, 2025 @ 1:00 PM"
                ];
            } else {
                endLines = [
                    "Defeat!", "Don't Give Up!", "Try Again at",
                    "Evelyn's Birthday Party!", "",
                    "Join us at UMAC Briarcliff", "528 N State Rd",
                    "Briarcliff Manor, NY 10510",
                    "April 26, 2025 @ 1:00 PM"
                ];
            }
            endText = createTextMesh(endLines.join('\n'), { x: 0, y: 0.5, z: 0 }, 0.7, true); // Adjusted scale/pos
            endText.material.opacity = 1;
            scene.add(endText);

            // Create a clickable HTML button for Play Again
            const playAgainButtonHTML = document.createElement('button');
            playAgainButtonHTML.id = 'playAgainButton'; // Add ID for easier selection
            playAgainButtonHTML.textContent = 'Play Again';
            playAgainButtonHTML.style.position = 'absolute';
            playAgainButtonHTML.style.left = '50%';
            playAgainButtonHTML.style.top = '80%';
            playAgainButtonHTML.style.transform = 'translate(-50%, -50%)';
            playAgainButtonHTML.style.padding = '15px 30px';
            playAgainButtonHTML.style.fontSize = '24px';
            playAgainButtonHTML.style.backgroundColor = '#00ff00';
            playAgainButtonHTML.style.color = 'white';
            playAgainButtonHTML.style.border = 'none';
            playAgainButtonHTML.style.borderRadius = '5px';
            playAgainButtonHTML.style.cursor = 'pointer';
            playAgainButtonHTML.style.fontFamily = 'Arial, sans-serif';
            playAgainButtonHTML.style.fontWeight = 'bold';
            playAgainButtonHTML.style.zIndex = '1000';
            playAgainButtonHTML.onclick = function() {
                // Remove the button immediately when clicked
                if (playAgainButtonHTML.parentNode) {
                    playAgainButtonHTML.parentNode.removeChild(playAgainButtonHTML);
                }
                startGameplay();
            };
            document.body.appendChild(playAgainButtonHTML);
            
            // Store reference - use let instead of const for playAgainButton in the global variables
            playAgainButton = playAgainButtonHTML;

            createConfetti();

            // Show a single end image as a Three.js sprite behind the text, scaled to 50%
            const endImageSrc = playerWon ? 'assets/images/evelyn-won.png' : 'assets/images/evelyn-lost.png';
            const loader = new THREE.TextureLoader();
            loader.load(endImageSrc, texture => {
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const endSprite = new THREE.Sprite(material);
                endSprite.name = 'endSprite';
                endSprite.position.set(0, 0.5, -1); // behind text at z=-1
                scaleSpriteToCamera(endSprite, camera, 0.5); // half-size
                scene.add(endSprite);
            });
        }

        // --- Asset Creation (Mostly unchanged, ensure materials allow transparency where needed) ---
        function createCharacter(giColor, hasBelt, isOpponent = false) {
            const group = new THREE.Group();
            
            // Set character ID
            group.userData.id = isOpponent ? 'opponent' : 'player';
            
            // Initialize AI-specific properties for opponent
            if (isOpponent) {
                group.userData.nextJumpTime = clock.getElapsedTime() + 2 + Math.random() * 3; // Initial jump decision in 2-5 seconds
                group.userData.originalColor = new THREE.Color(1, 1, 1); // Store original color for hit effect
            }
            
            // Load textures
            const textureLoader = new THREE.TextureLoader();
            const standingTexture = textureLoader.load('assets/images/evelyn-walking-001.png', texture => {
                // Create a canvas to extract pixel data for collision detection
                extractTextureData(texture, 'standing');
            });
            // Load block texture for player (used for block visual feedback)
            const blockTexture = textureLoader.load('assets/images/evelyn-block.png', texture => {
                extractTextureData(texture, 'block');
            });
            
            // Preload all kick frames (0001-0010)
            const kickTextures = [];
            for (let i = 1; i <= 10; i++) {
                const num = i.toString().padStart(3, '0');
                const texture = textureLoader.load(`assets/images/evelyn-kick-${num}.png`, texture => {
                    // Create a canvas to extract pixel data for collision detection
                    extractTextureData(texture, `kick-${num}`);
                });
                kickTextures.push(texture);
            }
            
            // Preload jump frames
            const jumpTextures = [
                textureLoader.load('assets/images/evelyn-jump-001.png', texture => {
                    // Create a canvas to extract pixel data for collision detection
                    extractTextureData(texture, 'jump-001');
                }),
                textureLoader.load('assets/images/evelyn-jump-002.png', texture => {
                    // Create a canvas to extract pixel data for collision detection
                    extractTextureData(texture, 'jump-002');
                })
            ];
            
            // Create sprite with proper aspect ratio
            const aspectRatio = 2285/2428;
            const planeGeometry = new THREE.PlaneGeometry(aspectRatio * 5.5, 5.5);
            const planeMaterial = new THREE.MeshBasicMaterial({
                map: standingTexture,
                transparent: true,
                side: THREE.DoubleSide,
                depthTest: true, // Enable depth testing
                depthWrite: true, // Enable depth writing
                alphaTest: 0.1 // Discard pixels with alpha < 0.1 to prevent semi-transparent edges
            });
            
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.position.y = 0.0;
            
            // If this is the opponent, flip horizontally by scaling negative on X axis
            if (isOpponent) {
                plane.scale.x = -1; // This flips the sprite horizontally
                plane.position.z = 0.1; // Position opponent slightly behind player to prevent z-fighting
            } else {
                plane.position.z = 0; // Player in front
                
                // Set renderOrder to ensure player always renders on top when overlapping
                plane.renderOrder = 1;
            }
            
            group.add(plane);
            
            // Load punch textures
            const punchTextures = [];
            for (let i = 1; i <= 10; i++) {
                const num = i.toString().padStart(3, '0');
                const texture = textureLoader.load(`assets/images/evelyn-punch-${num}.png`, texture => {
                    extractTextureData(texture, `punch-${num}`);
                });
                punchTextures.push(texture);
            }
            // Store animation data
            group.userData = {
                body: plane,
                standingTexture: standingTexture,
                blockTexture: blockTexture, // Add block texture for blocking visual
                kickTextures: kickTextures,
                punchTextures: punchTextures,
                jumpTextures: jumpTextures,
                isKicking: false,
                isPunching: false,
                isJumping: false,
                currentKickFrame: 0,
                currentPunchFrame: 0,
                currentJumpFrame: 0,
                kickTimer: 0,
                punchTimer: 0
            };
            
            return group;
        }

        function createTextMesh(text, position, scale = 1, transparent = true, centerAlign = true) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const lines = text.split('\n');
            const fontSize = 32 * window.devicePixelRatio; // Adjust for device pixel ratio
            context.font = CONFIG.UI.font.replace(/\d+px/, fontSize + 'px');

            let maxWidth = 0;
            lines.forEach(line => { maxWidth = Math.max(maxWidth, context.measureText(line).width); });
            const lineHeight = fontSize * 1.2;
            canvas.width = THREE.MathUtils.ceilPowerOfTwo(maxWidth + 20 * window.devicePixelRatio);
            canvas.height = THREE.MathUtils.ceilPowerOfTwo(lines.length * lineHeight + 10 * window.devicePixelRatio);

            context.font = CONFIG.UI.font.replace(/\d+px/, fontSize + 'px'); // Re-apply font after resize
            context.fillStyle = CONFIG.UI.fontColor;
            context.strokeStyle = CONFIG.UI.outlineColor;
            context.lineWidth = 4 * window.devicePixelRatio;
            context.textAlign = centerAlign ? 'center' : 'left';
            context.textBaseline = 'middle'; // Adjust baseline for better centering

            const startX = centerAlign ? canvas.width / 2 : 10 * window.devicePixelRatio;
            const startY = canvas.height / 2 - (lines.length - 1) * lineHeight / 2; // Center vertically

            lines.forEach((line, index) => {
                const yPos = startY + index * lineHeight;
                context.strokeText(line, startX, yPos);
                context.fillText(line, startX, yPos);
            });

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            texture.minFilter = THREE.LinearFilter; // Nicer scaling

            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: transparent,
                opacity: transparent ? 1 : 1,
                depthTest: false, // Render text on top
                depthWrite: false,
            });

            const planeWidth = canvas.width / (150 / scale); // Adjust scaling base
            const planeHeight = canvas.height / (150 / scale);
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(position.x, position.y, position.z);
            mesh.renderOrder = 1; // Ensure text renders on top
            return mesh;
        }

        function createButtonMesh(text, color, position) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 48 * window.devicePixelRatio;
            const buttonPadding = 20 * window.devicePixelRatio;
            context.font = `bold ${fontSize}px Arial`;

            const textMetrics = context.measureText(text);
            const textWidth = textMetrics.width;
            canvas.width = THREE.MathUtils.ceilPowerOfTwo(textWidth + buttonPadding * 2);
            canvas.height = THREE.MathUtils.ceilPowerOfTwo(fontSize * 1.5);

            context.font = `bold ${fontSize}px Arial`; // Re-apply

            context.fillStyle = `rgba(${Math.floor(color >> 16 & 255)}, ${Math.floor(color >> 8 & 255)}, ${Math.floor(color & 255)}, ${0.7})`;
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.fillStyle = CONFIG.UI.fontColor;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true; texture.minFilter = THREE.LinearFilter;
            const geo = new THREE.PlaneGeometry(CONFIG.UI.buttonWidth, CONFIG.UI.buttonHeight);
            const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, depthTest: false, depthWrite: false });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(position.x, position.y, position.z);
            mesh.renderOrder = 1; // Ensure button renders on top
            return mesh;
        }

        function createHTMLHealthBars() {
            const playerHealthBar = document.getElementById('player-health-bar');
            const opponentHealthBar = document.getElementById('opponent-health-bar');

            // Show the health bars during gameplay
            playerHealthBar.style.display = 'block';
            opponentHealthBar.style.display = 'block';

            // Reset health bar fills to full
            const playerHealthBarFill = document.getElementById('player-health-bar-fill');
            playerHealthBarFill.style.width = '100%';
            playerHealthBarFill.style.transform = 'scaleX(1)';

            const opponentHealthBarFill = document.getElementById('opponent-health-bar-fill');
            opponentHealthBarFill.style.width = '100%';
            opponentHealthBarFill.style.transform = 'scaleX(1)';
        }

        function updateHealthBar(isPlayer, currentHealth) {
            const healthBar = isPlayer ? document.getElementById('player-health-bar-fill') : document.getElementById('opponent-health-bar-fill');
            const healthPercentage = Math.max(0, currentHealth / CONFIG.HEALTH.max);
            
            // For both bars, we'll use transform to scale them properly from the correct edge
            healthBar.style.transform = `scaleX(${healthPercentage})`;
        }

        function createMobileControls() {
            const buttonSize = CONFIG.UI.mobileButtonSize;
            const opacity = CONFIG.UI.mobileButtonOpacity;

            const createButton = (color, name, icon) => {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');

                // Draw fully opaque background for debug
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = `rgb(${Math.floor(color >> 16 & 255)}, ${Math.floor(color >> 8 & 255)}, ${Math.floor(color & 255)})`;
                ctx.beginPath(); ctx.arc(32, 32, 30, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1.0;
                // Draw a solid outline for debug
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#fff';
                ctx.beginPath(); ctx.arc(32, 32, 30, 0, Math.PI * 2); ctx.stroke();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#000';
                ctx.beginPath(); ctx.arc(32, 32, 30, 0, Math.PI * 2); ctx.stroke();
                // Draw a large label for debug
                ctx.font = 'bold 32px Arial';
                ctx.fillStyle = 'yellow';
                let label = '?';
                if (icon === 'left') label = 'L';
                else if (icon === 'right') label = 'R';
                else if (icon === 'up') label = 'U';
                else if (icon === 'punch') label = 'P';
                else if (icon === 'kick') label = 'K';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, 32, 32);

                ctx.fillStyle = 'white'; ctx.strokeStyle = 'black'; ctx.lineWidth = 3;
                if (icon === 'left') { ctx.beginPath(); ctx.moveTo(45, 15); ctx.lineTo(19, 32); ctx.lineTo(45, 49); ctx.stroke(); ctx.fill(); }
                else if (icon === 'right') { ctx.beginPath(); ctx.moveTo(19, 15); ctx.lineTo(45, 32); ctx.lineTo(19, 49); ctx.stroke(); ctx.fill(); }
                else if (icon === 'up') { ctx.beginPath(); ctx.moveTo(32, 15); ctx.lineTo(47, 30); ctx.lineTo(37, 30); ctx.lineTo(37, 49); ctx.lineTo(27, 49); ctx.lineTo(27, 30); ctx.lineTo(17, 30); ctx.closePath(); ctx.stroke(); ctx.fill(); }
                else if (icon === 'punch') { 
                    // Draw a fist icon for punch
                    ctx.beginPath(); 
                    ctx.arc(32, 32, 15, 0, Math.PI * 2); // Draw fist
                    ctx.fill(); ctx.stroke();
                    // Draw knuckles
                    ctx.beginPath();
                    ctx.moveTo(22, 25); ctx.lineTo(42, 25); 
                    ctx.moveTo(22, 32); ctx.lineTo(42, 32);
                    ctx.stroke();
                }
                else if (icon === 'kick') { 
                    // Draw a foot icon for kick
                    ctx.beginPath();
                    // Leg
                    ctx.moveTo(20, 15); 
                    ctx.lineTo(32, 32);
                    // Foot
                    ctx.lineTo(45, 25);
                    ctx.lineTo(48, 35);
                    ctx.lineTo(32, 38);
                    ctx.closePath();
                    ctx.fill(); ctx.stroke();
                }

                const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true; texture.minFilter = THREE.LinearFilter;
                const geo = new THREE.PlaneGeometry(buttonSize, buttonSize);
                // Use MeshBasicMaterial, depthTest: false to ensure they are drawn on top and don't interact with scene depth
                const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 1, depthTest: false, depthWrite: false });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.visible = true; // Make buttons visible by default
                mesh.userData.action = name;
                mesh.renderOrder = 2; // Render mobile controls above everything else
                camera.add(mesh); // Add to camera
                return mesh;
            };

            mobileButtons.left = createButton(CONFIG.COLORS.mobileLeftRight, 'moveLeft', 'left');
            mobileButtons.right = createButton(CONFIG.COLORS.mobileLeftRight, 'moveRight', 'right');
            mobileButtons.jump = createButton(CONFIG.COLORS.mobileJump, 'jump', 'up');
            mobileButtons.punch = createButton(CONFIG.COLORS.mobilePunch, 'attackPunch', 'punch');
            mobileButtons.kick = createButton(CONFIG.COLORS.mobileKick, 'attackKick', 'kick');
            positionMobileControls(); // Set initial positions
            // Debug log after positioning
            Object.entries(mobileButtons).forEach(([key, btn]) => {
                console.log('[BUTTON POSITIONED]', key, 'at', btn.position.x, btn.position.y, btn.position.z, 'visible:', btn.visible);
            });
        }

        function positionMobileControls() {
            if(!mobileButtons.left) return; // Don't position if not created yet

            const H = window.innerHeight;
            const W = window.innerWidth;
            // Position based on viewport size using NDC-like values relative to camera
             const scaleFactor = Math.min(W, H) / 500; // Adjust base size for different screens
             const btnSize = CONFIG.UI.mobileButtonSize * scaleFactor;
             const margin = 0.15 * scaleFactor; // Margin scaled too

             Object.values(mobileButtons).forEach(btn => {btn.scale.set(scaleFactor, scaleFactor, 1)});

            // Use view coordinates (relative to camera)
            const aspect = W / H;
            const viewHeight = 4; // Adjust this based on camera FOV and distance if needed
            const viewWidth = viewHeight * aspect;
            const camZOffset = -3; // Push slightly further away

            // Positioning logic (bottom corners)
            const bottomY = -viewHeight / 2 + margin + btnSize / 2;
            const leftX = -viewWidth / 2 + margin + btnSize / 2;
            const rightX = viewWidth / 2 - margin - btnSize / 2;
            
            // LEFT SIDE: Arrow keys in a layout with jump (up) above the left/right arrows
            const leftMiddleY = bottomY + btnSize + margin*0.5; // Position for jump button above left/right
            
            // Position left/right arrows at the bottom
            mobileButtons.left.position.set(leftX, bottomY, camZOffset);
            mobileButtons.right.position.set(leftX + btnSize + margin*0.5, bottomY, camZOffset);
            
            // Position jump (up) button above the left/right arrows
            mobileButtons.jump.position.set(leftX + btnSize/2 + margin*0.25, leftMiddleY, camZOffset);

            // RIGHT SIDE: Attack buttons
            mobileButtons.punch.position.set(rightX, bottomY, camZOffset);
            mobileButtons.kick.position.set(rightX - btnSize - margin*0.5, bottomY, camZOffset);
        }

        function createConfetti() {
            // First make sure any existing confetti is cleared
            confetti.forEach(confetto => {
                scene.remove(confetto);
                if (confetto.geometry) confetto.geometry.dispose();
                if (confetto.material) confetto.material.dispose();
            });
            confetti = [];
            
            // Remove any existing confetti group
            const existingConfettiGroup = scene.getObjectByName('confettiGroup');
            if (existingConfettiGroup) {
                scene.remove(existingConfettiGroup);
            }
            
            // Create new confetti
            const confettiGroup = new THREE.Group();
            confettiGroup.name = 'confettiGroup';
            const confettiGeo = new THREE.SphereGeometry(0.05, 6, 6);

            for (let i = 0; i < CONFIG.CONFETTI.count; i++) {
                const confettiMat = new THREE.MeshBasicMaterial({ color: CONFIG.CONFETTI.colors[Math.floor(Math.random() * CONFIG.CONFETTI.colors.length)] });
                const particle = new THREE.Mesh(confettiGeo, confettiMat);
                particle.position.set(
                    (Math.random() - 0.5) * CONFIG.ARENA.width * 0.8,
                    CONFIG.CONFETTI.spawnY + (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                particle.userData.velocity = new THREE.Vector3(
                     (Math.random() - 0.5) * 0.01,
                     -CONFIG.CONFETTI.fallSpeed * (0.8 + Math.random() * 0.4),
                     (Math.random() - 0.5) * 0.01
                 );
                confettiGroup.add(particle);
                confetti.push(particle);
            }
            scene.add(confettiGroup);
            console.log('Created new confetti:', confetti.length, 'particles');
        }

        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            positionMobileControls();
            // Rescale dojo background
            if (backgroundSprite) scaleSpriteToCamera(backgroundSprite, camera, 1.0);
            // If intro/ending image is present, rescale that too (pattern for you to use):
            if (typeof introCharacter !== 'undefined' && introCharacter && introCharacter.material && introCharacter.material.map) {
                scaleSpriteToCamera(introCharacter, camera, 1.0);
            }
            if (typeof endCharacter !== 'undefined' && endCharacter && endCharacter.material && endCharacter.material.map) {
                scaleSpriteToCamera(endCharacter, camera, 1.0);
            }
        }

        function onKeyDown(event) {
            keysPressed[event.code] = true;
            
            // Only process gameplay inputs during gameplay state
            if (gameState === 'gameplay') {
                // 'c' triggers a kick
                if (event.key === 'c' || event.key === 'C') {
                    event.preventDefault();
                    handleAttackInput('player', 'kick');
                }
                // 'x' triggers a punch
                if (event.key === 'x' || event.key === 'X') {
                    event.preventDefault();
                    handleAttackInput('player', 'punch');
                }
                // 'z' triggers block
                if (event.key === 'z' || event.key === 'Z') {
                    event.preventDefault();
                    // Set blocking state
                    player.userData.blocking = true;
                    // Set block texture for visual feedback
                    if (player.userData.blockTexture) {
                        player.userData.body.material.map = player.userData.blockTexture;
                        player.userData.body.material.needsUpdate = true;
                    }
                }
                if (event.code === 'ArrowUp') { 
                    event.preventDefault(); 
                    handleJumpInput('player'); 
                }
            }
        }

        function onKeyUp(event) {
            keysPressed[event.code] = false;
            
            // Handle block release (Z key)
            if (gameState === 'gameplay' && (event.key === 'z' || event.key === 'Z')) {
                player.userData.blocking = false;
                // Revert to standing texture when block is released
                if (player.userData.standingTexture) {
                    player.userData.body.material.map = player.userData.standingTexture;
                    player.userData.body.material.needsUpdate = true;
                }
            }
        }

        // --- Pointer (Mouse/Touch) Handlers ---
        function handlePointerInteraction(event, isDown) {
             // Calculate pointer position in normalized device coordinates (-1 to +1)
             pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
             pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

             // Raycast against UI buttons attached to camera
             raycaster.setFromCamera(pointer, camera);
             const intersectsUI = raycaster.intersectObjects(Object.values(mobileButtons));

             if (intersectsUI.length > 0) {
                 const button = intersectsUI[0].object;
                 const action = button.userData.action;

                 if (isDown) {
                     activeMobileInputs[event.pointerId] = action; // Track which button this pointer pressed
                     if (action === 'moveLeft') keysPressed['MobileLeft'] = true;
                     else if (action === 'moveRight') keysPressed['MobileRight'] = true;
                     else if (action === 'jump') handleJumpInput('player');
                     else if (action === 'attackPunch' || action === 'attackKick') handleAttackInput('player', action === 'attackPunch' ? 'punch' : 'kick');
                 }
                 return true; // Indicate UI interaction happened
             }

             // Raycast against scene objects (Start/Play Again) only on pointer down
            if (isDown) {
                // Use the same raycaster that's already set up with the pointer position
                if (gameState === 'intro' && startButton) {
                    // For menu buttons, we need to check recursively to handle button meshes properly
                    const intersectsScene = raycaster.intersectObject(startButton, true);
                    if (intersectsScene.length > 0) {
                        startGameplay(); 
                        return true;
                    }
                } else if (gameState === 'ending' && playAgainButton) {
                    const intersectsScene = raycaster.intersectObject(playAgainButton, true);
                     if (intersectsScene.length > 0) {
                         startGameplay(); 
                         return true;
                     }
                }
            }
             return false; // No UI interaction
         }

        function onPointerDown(event) {
            event.preventDefault();
            handlePointerInteraction(event, true);
        }

        function onPointerUp(event) {
             event.preventDefault();
             const releasedAction = activeMobileInputs[event.pointerId];
             if (releasedAction === 'moveLeft') keysPressed['MobileLeft'] = false;
             if (releasedAction === 'moveRight') keysPressed['MobileRight'] = false;
             delete activeMobileInputs[event.pointerId]; // Clear tracked input

             // Might need to check if *any* pointer is still down on a move button
             // This simple version assumes one touch per button type at a time
             let stillMovingLeft = false;
             let stillMovingRight = false;
             for (const id in activeMobileInputs) {
                 if (activeMobileInputs[id] === 'moveLeft') stillMovingLeft = true;
                 if (activeMobileInputs[id] === 'moveRight') stillMovingRight = true;
             }
             if (!stillMovingLeft) keysPressed['MobileLeft'] = false;
             if (!stillMovingRight) keysPressed['MobileRight'] = false;
        }

        function onPointerMove(event) {
            // If a pointer moves off its button, treat it as pointer up for that button
            event.preventDefault();
             if (!activeMobileInputs[event.pointerId]) return; // Only care if this pointer was down on a button

             pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
             pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
             raycaster.setFromCamera(pointer, camera);
             const intersectsUI = raycaster.intersectObjects(Object.values(mobileButtons));

             let stillOnButton = false;
             if (intersectsUI.length > 0) {
                 const button = intersectsUI[0].object;
                 const action = button.userData.action;

                 if(intersectsUI[0].object.userData.action === activeMobileInputs[event.pointerId]) {
                    stillOnButton = true;
                 }
             }

             if (!stillOnButton) {
                // Moved off the button, trigger release for that action
                const releasedAction = activeMobileInputs[event.pointerId];
                if (releasedAction === 'moveLeft') keysPressed['MobileLeft'] = false;
                if (releasedAction === 'moveRight') keysPressed['MobileRight'] = false;
                 delete activeMobileInputs[event.pointerId];

                 // Re-check if any *other* pointer is still holding move buttons
                 // (Same logic as onPointerUp)
                 let stillMovingLeft = false;
                 let stillMovingRight = false;
                 for (const id in activeMobileInputs) {
                     if (activeMobileInputs[id] === 'moveLeft') stillMovingLeft = true;
                     if (activeMobileInputs[id] === 'moveRight') stillMovingRight = true;
                 }
                 if (!stillMovingLeft) keysPressed['MobileLeft'] = false;
                 if (!stillMovingRight) keysPressed['MobileRight'] = false;
             }
        }

        function onPointerLeave(event) {
             // Treat leaving the canvas like pointer up for all active inputs from that pointer
             event.preventDefault();
             onPointerUp(event); // Simulate pointer up
        }

        // --- Input Processing ---
        function handleJumpInput(characterId) {
            const char = (characterId === 'player') ? player : opponent;
            if (!char || !char.userData) return;
            
            if (!char.userData.jumping && gameState === 'gameplay') {
                char.userData.jumping = true;
                char.userData.velocityY = CONFIG.MOVEMENT.jumpVelocity;
                // Set initial jump frame
                char.userData.body.material.map = char.userData.jumpTextures[0];
                char.userData.body.material.needsUpdate = true;
            }
        }

        function handleAttackInput(characterId, attackType) {
            const char = (characterId === 'player') ? player : opponent;
            if (!char || !char.userData) {
                console.log(`Attack input failed: invalid character ${characterId}`);
                return; // Guard
            }
            const now = clock.getElapsedTime();
            
            console.log(`Attack input for ${characterId}: currentState=${gameState}, isKicking=${char.userData.isKicking}, currentKickFrame=${char.userData.currentKickFrame || 0}, cooldown=${((now - char.userData.lastAttackTime) * 1000).toFixed(0)}ms`);

            // Ensure we can attack if not currently kicking, regardless of attacking state
            // This fixes the issue where attacking state might be out of sync
            if ((!char.userData.isKicking || char.userData.currentKickFrame >= char.userData.kickTextures.length - 1) && 
                gameState === 'gameplay' && (now - char.userData.lastAttackTime > CONFIG.ATTACK.cooldown / 1000)) {
                
                // Reset hit flag for new attack
                char.userData.hitThisAttack = false;
                char.userData.attacking = true;
                
                // Use specified attack type if provided, otherwise alternate
                if (attackType) {
                    char.userData.attackType = attackType;
                } else if (characterId === 'player') {
                   char.userData.attackType = (char.userData.attackType === 'punch') ? 'kick' : 'punch';
                } else {
                    char.userData.attackType = (Math.random() < 0.5) ? 'punch' : 'kick'; // AI random attack
                }
                
                console.log(`${characterId} starting attack: ${char.userData.attackType}`);
                
                // For kick attacks, also set isKicking for animation
                if (char.userData.attackType === 'kick') {
                    // Force reset any previous kick animation
                    char.userData.isKicking = true;
                    char.userData.kickTimer = 0;
                    char.userData.currentKickFrame = 0;
                    char.userData.isPunching = false;
                    char.userData.punchTimer = 0;
                    char.userData.currentPunchFrame = 0;
                    // Set first frame immediately
                    char.userData.body.material.map = char.userData.kickTextures[0];
                    char.userData.body.material.needsUpdate = true;
                    console.log(`${characterId} starting kick animation with texture: kick-001`);
                } else if (char.userData.attackType === 'punch') {
                    char.userData.isPunching = true;
                    char.userData.punchTimer = 0;
                    char.userData.currentPunchFrame = 0;
                    char.userData.isKicking = false;
                    char.userData.kickTimer = 0;
                    char.userData.currentKickFrame = 0;
                    // Set first frame immediately
                    char.userData.body.material.map = char.userData.punchTextures[0];
                    char.userData.body.material.needsUpdate = true;
                    console.log(`${characterId} starting punch animation with texture: punch-001`);
                }
                
                char.userData.attackTimer = (char.userData.attackType === 'punch') ? 
                    CONFIG.ATTACK.punchDuration : CONFIG.ATTACK.kickDuration;
                char.userData.lastAttackTime = now;
            } else {
                // console.log(`Attack input rejected: ${!char.userData.isKicking ? '' : 'still kicking, '} ${gameState !== 'gameplay' ? 'not in gameplay, ' : ''} ${(now - char.userData.lastAttackTime <= CONFIG.ATTACK.cooldown / 1000) ? 'cooldown active' : ''}`);
            }
        }

        // --- Game Logic ---
        function updatePlayer(deltaTime) {
    if (player && player.userData) {
        console.log(`[PUNCH DEBUG] updatePlayer called. isPunching=${player.userData.isPunching}, isKicking=${player.userData.isKicking}, isJumping=${player.userData.jumping}, currentPunchFrame=${player.userData.currentPunchFrame}`);
    }
            if (gameState !== 'gameplay' || !player) return;
            
            // Get current time for animation debugging
            const now = clock.getElapsedTime();
            
            // Process movement input
            let moveDirection = 0;
            if (keysPressed['ArrowLeft'] || keysPressed['a']) moveDirection -= 1;
            if (keysPressed['ArrowRight'] || keysPressed['d']) moveDirection += 1;
            if (activeMobileInputs['left']) moveDirection -= 1;
            if (activeMobileInputs['right']) moveDirection += 1;
            
            // First time initialization of walking animation system
            if (!player.userData.walkingAnimationInitialized && !player.userData.attacking) {
                console.log('[WALKING ANIM] Initializing walking animation system');
                
                // Create and store all walking textures directly
                player.userData.walkingTextures = [];
                
                // Load all textures directly (no promises or async)
                for (let i = 1; i <= 10; i++) {
                    const paddedIndex = i.toString().padStart(3, '0');
                    const filename = `assets/images/evelyn-walking-${paddedIndex}.png`;
                    
                    // Create texture and add to array
                    const texture = new THREE.TextureLoader().load(filename);
                    player.userData.walkingTextures.push(texture);
                    
                    console.log(`[WALKING ANIM] Directly loaded texture ${i}: ${filename}`);
                }
                
                // Initialize animation variables
                player.userData.walkingAnimationInitialized = true;
                player.userData.currentWalkingFrame = 0;
                player.userData.walkingTimer = 0;
                player.userData.isWalking = false;
                player.userData.walkingDirection = 0;
                player.userData.standingTexture = player.userData.walkingTextures[0];
                
                console.log('[WALKING ANIM] Walking animation system initialized with', 
                           player.userData.walkingTextures.length, 'textures');
            }
            
            // 1. Determine move direction (Removed duplicate declaration)
            moveDirection = 0; // Assign to existing variable
            if (keysPressed['ArrowLeft'] || keysPressed['a'] || keysPressed['MobileLeft']) moveDirection -= 1;
            if (keysPressed['ArrowRight'] || keysPressed['d'] || keysPressed['MobileRight']) moveDirection += 1;

            // 2. Determine walking state for THIS frame (can't walk while attacking or jumping)
            const shouldBeWalking = (moveDirection !== 0 && !player.userData.attacking && !player.userData.jumping);

            // 3. Update walking state and log changes
            if (shouldBeWalking && (!player.userData.isWalking || player.userData.walkingDirection !== moveDirection)) {
                player.userData.isWalking = true;
                player.userData.walkingDirection = moveDirection;
                // Reset frame index when starting to walk or changing direction
                player.userData.currentWalkingFrame = 0;
                player.userData.walkingTimer = 0;
                console.log(`[WALKING ANIM] Started walking in direction: ${moveDirection}`);
            } else if (!shouldBeWalking && player.userData.isWalking) {
                // Set intent to stop walking, animation function will handle texture reset
                player.userData.isWalking = false;
                player.userData.walkingDirection = 0;
                console.log('[WALKING ANIM] Stopped walking intent');
            }

            // 4. Apply movement if walking state is true
            if (player.userData.isWalking) {
                const newX = player.position.x + player.userData.walkingDirection * CONFIG.MOVEMENT.speed;

                // Check boundaries
                let finalX = newX;
                if (newX - CHARACTER_HALF_WIDTH <= SCREEN_LEFT) {
                    finalX = SCREEN_LEFT + CHARACTER_HALF_WIDTH;
                } else if (newX + CHARACTER_HALF_WIDTH >= SCREEN_RIGHT) {
                    finalX = SCREEN_RIGHT - CHARACTER_HALF_WIDTH;
                }

                // Check collision with opponent
                if (opponent) {
                    const minDistance = CHARACTER_HALF_WIDTH * 1.5; // Minimum distance between characters
                    const potentialDistance = Math.abs(finalX - opponent.position.x);

                    if (potentialDistance < minDistance) {
                        console.log(`Collision prevented: player would be too close to opponent (${potentialDistance.toFixed(2)} < ${minDistance.toFixed(2)})`);
                        
                        // Prevent player from moving through opponent by adjusting finalX
                        if (finalX < opponent.position.x) {
                            // Player is to the left of opponent
                            finalX = opponent.position.x - minDistance;
                        } else {
                            // Player is to the right of opponent
                            finalX = opponent.position.x + minDistance;
                        }
                    }
                }
                player.position.x = finalX;
            }

            // 5. Handle jumping physics
    // DEBUG: End of updatePlayer, punch state
    if (player && player.userData) {
        console.log(`[PUNCH DEBUG] End of updatePlayer. isPunching=${player.userData.isPunching}, currentPunchFrame=${player.userData.currentPunchFrame}`);
    }
            if (player.userData.jumping) {
                // Apply gravity (scale with deltaTime for consistent behavior)
                player.userData.velocityY -= CONFIG.MOVEMENT.gravity * deltaTime * 60;
                
                // Update vertical position
                const newY = player.position.y + player.userData.velocityY;
                
                // Enforce maximum jump height
                if (newY > CONFIG.MOVEMENT.maxJumpHeight) {
                    player.position.y = CONFIG.MOVEMENT.maxJumpHeight;
                    player.userData.velocityY = 0; // Start falling
                } else if (newY <= GROUND_Y) {
                    // Ground collision - ensure character is at proper floor level
                    player.position.y = GROUND_Y;
                    player.userData.jumping = false;
                    player.userData.velocityY = 0;
                    // If landing while move keys are released, ensure walking stops
                    if (moveDirection === 0) {
                        player.userData.isWalking = false;
                    }
                    // Standing texture reset is handled by updateWalkingAnimation or below
                } else {
                    player.position.y = newY;
                }
            }
            
            // Attack handling
            if (player.userData.attacking) {
                player.userData.attackTimer -= deltaTime * 1000;
                if (player.userData.attackTimer <= 0) {
                    player.userData.attacking = false;
                    // Reset hit flag when attack ends
                    player.userData.hitThisAttack = false;
                    // For punches, check hit at the end
                    if (opponent && player.userData.attackType === 'punch') {
                        checkAttackHit(player, opponent);
                    }
                }
            }
            
            // Always ensure attacking state is false when not kicking
            if (!player.userData.isKicking && player.userData.attacking) {
                player.userData.attacking = false;
            }
            
            // 6. Attack handling (unchanged from original logic)
            if (player.userData.attacking) {
                player.userData.attackTimer -= deltaTime * 1000;
                if (player.userData.attackTimer <= 0) {
                    player.userData.attacking = false;
                    player.userData.hitThisAttack = false;
                    if (opponent && player.userData.attackType === 'punch') {
                        checkAttackHit(player, opponent);
                    }
                }
            }
            if (!player.userData.isKicking && player.userData.attacking) {
                 player.userData.attacking = false; // Ensure consistency
            }

            updateHealthBar(true, player.userData.health);
        }

        function updateOpponent(deltaTime) {
            if (!opponent.userData.walkingAnimationInitialized && !opponent.userData.attacking) {
                console.log('[WALKING ANIM] Initializing walking animation system for opponent');
                opponent.userData.walkingTextures = [];
                for (let i = 1; i <= 10; i++) {
                    const paddedIndex = i.toString().padStart(3, '0');
                    const filename = `assets/images/evelyn-walking-${paddedIndex}.png`;
                    const texture = new THREE.TextureLoader().load(filename);
                    opponent.userData.walkingTextures.push(texture);
                    console.log(`[WALKING ANIM] (Opponent) Directly loaded texture ${i}: ${filename}`);
                }
                opponent.userData.walkingAnimationInitialized = true;
                opponent.userData.currentWalkingFrame = 0;
                opponent.userData.walkingTimer = 0;
                opponent.userData.isWalking = false;
                opponent.userData.walkingDirection = 0;
                opponent.userData.standingTexture = opponent.userData.walkingTextures[0];
                console.log('[WALKING ANIM] (Opponent) Walking animation system initialized with', opponent.userData.walkingTextures.length, 'textures');
            }
            if (gameState !== 'gameplay' || !opponent) return;
            
            const now = clock.getElapsedTime();
            
            // Handle jumping physics for opponent
            if (opponent.userData.jumping) {
                // Apply gravity (scale with deltaTime for consistent behavior)
                opponent.userData.velocityY -= CONFIG.MOVEMENT.gravity * deltaTime * 60;
                
                // Update vertical position
                const newY = opponent.position.y + opponent.userData.velocityY;
                
                // Enforce maximum jump height
                if (newY > CONFIG.MOVEMENT.maxJumpHeight) {
                    opponent.position.y = CONFIG.MOVEMENT.maxJumpHeight;
                    opponent.userData.velocityY = 0; // Start falling
                } else if (newY <= GROUND_Y) {
                    // Ground collision - ensure character is at proper floor level
                    opponent.position.y = GROUND_Y;
                    opponent.userData.jumping = false;
                    opponent.userData.velocityY = 0;
                    
                    // Explicitly reset to standing texture on landing
                    opponent.userData.body.material.map = opponent.userData.standingTexture;
                    opponent.userData.body.material.needsUpdate = true;
                } else {
                    opponent.position.y = newY;
                }
            }
            
            // AI decision making - make sure opponent has all required properties
            if (opponent.userData.nextJumpTime === undefined) {
                opponent.userData.nextJumpTime = now + 1 + Math.random() * 2;
                console.log('Fixed missing nextJumpTime for opponent');
            }
            
            // Debug - log opponent state periodically
            if (Math.floor(now) % 5 === 0 && Math.floor(now) !== opponent.userData.lastDebugTime) {
                opponent.userData.lastDebugTime = Math.floor(now);
                console.log('Opponent state:', {
                    position: opponent.position,
                    jumping: opponent.userData.jumping,
                    attacking: opponent.userData.attacking,
                    isKicking: opponent.userData.isKicking,
                    attackType: opponent.userData.attackType,
                    nextJumpTime: opponent.userData.nextJumpTime - now,
                    nextAttackTime: opponent.userData.nextAttackTime - now
                });
            }
            
            // AI decision making - only when not jumping or attacking
            if (!opponent.userData.jumping && !opponent.userData.attacking) {
                // Decide on movement
                if (now > opponent.userData.nextMoveTime) {
                    opponent.userData.moveDirection = (Math.random() < 0.5) ? -1 : 1;
                    opponent.userData.nextMoveTime = now + Math.random() * (CONFIG.AI.moveIntervalMax - CONFIG.AI.moveIntervalMin) / 1000 + CONFIG.AI.moveIntervalMin / 1000;
                }
                
                // Decide on jumping - 40% chance to jump when decision point is reached
                if (now > opponent.userData.nextJumpTime && Math.random() < 0.4) {
                    // Initiate jump
                    opponent.userData.jumping = true;
                    opponent.userData.velocityY = CONFIG.MOVEMENT.jumpVelocity;
                    opponent.userData.body.material.map = opponent.userData.jumpTextures[0];
                    opponent.userData.body.material.needsUpdate = true;
                    
                    // Set next jump decision time
                    opponent.userData.nextJumpTime = now + 2 + Math.random() * 2; // 2-4 seconds between jump decisions
                    console.log('Opponent decided to jump! Next jump decision in', opponent.userData.nextJumpTime - now, 'seconds');
                }
                
                // Decide on attacks - more likely to attack when close to player
                if (now > opponent.userData.nextAttackTime) {
                    console.log('Opponent making attack decision at time', now);
                    const distanceToPlayer = player ? Math.abs(opponent.position.x - player.position.x) : 999;
                    let attackProbability = 0.5; // Base probability
                    
                    // Reset hit flag before new attacks
                    opponent.userData.hitThisAttack = false;
                    
                    // Increase attack probability when close to player
                    if (distanceToPlayer < CHARACTER_HALF_WIDTH * 3) {
                        attackProbability = 0.8; // 80% chance to attack when close
                    }
                    
                    // We'll let the existing opponent movement code handle facing direction
                    
                    const attackRoll = Math.random();
                    console.log('Opponent attack probability:', attackProbability, 'Roll:', attackRoll);
                    if (attackRoll < attackProbability) {
                        opponent.userData.attacking = true;
                        
                        // More likely to kick when at medium distance, punch when very close
                        if (distanceToPlayer < CHARACTER_HALF_WIDTH * 2) {
                            // Close range - prefer punch (70% chance)
                            opponent.userData.attackType = (Math.random() < 0.3) ? 'punch' : 'kick'; // 70% chance to kick at close range
                        } else {
                            // Medium range - prefer kick (80% chance)
                            opponent.userData.attackType = (Math.random() < 0.1) ? 'punch' : 'kick'; // 90% chance to kick at medium range
                        }
                        
                        opponent.userData.attackTimer = (opponent.userData.attackType === 'punch') ? 
                            CONFIG.ATTACK.punchDuration : CONFIG.ATTACK.kickDuration;
                            
                        // Start kick animation immediately if kick is chosen
                        if (opponent.userData.attackType === 'kick' && !opponent.userData.isKicking) {
                            opponent.userData.isKicking = true;
                            opponent.userData.currentKickFrame = 0;
                            opponent.userData.kickTimer = 0;
                            opponent.userData.body.material.map = opponent.userData.kickTextures[0];
                            opponent.userData.body.material.needsUpdate = true;
                            console.log('Opponent started kick animation!');
                        }
                            
                        console.log('Opponent decided to attack with:', opponent.userData.attackType);
                    }
                    
                    // Set next attack decision time - shorter interval for more frequent attacks
                    opponent.userData.nextAttackTime = now + Math.random() * (CONFIG.AI.attackIntervalMax - CONFIG.AI.attackIntervalMin) / 1000 + CONFIG.AI.attackIntervalMin / 2000;
                    console.log('Next opponent attack decision in', opponent.userData.nextAttackTime - now, 'seconds');
                }
            }
            
            // Calculate potential new position - only move when not jumping or attacking
            if (!opponent.userData.jumping && !opponent.userData.attacking) {
                let moveDirection = opponent.userData.moveDirection;
                let newX = opponent.position.x + moveDirection * CONFIG.MOVEMENT.speed * 0.7;
                let actuallyMoving = false;
                // Check boundaries
                if (newX - CHARACTER_HALF_WIDTH > SCREEN_LEFT && 
                    newX + CHARACTER_HALF_WIDTH < SCREEN_RIGHT) {
                    // Check if this would cause collision with player
                    if (player) {
                        const minDistance = CHARACTER_HALF_WIDTH * 1.5; // Minimum distance between characters
                        const potentialDistance = Math.abs(newX - player.position.x);
                        if (potentialDistance < minDistance) {
                            console.log(`Collision prevented: opponent would be too close to player (${potentialDistance.toFixed(2)} < ${minDistance.toFixed(2)})`); 
                            // Adjust opponent position to maintain minimum distance
                            if (newX < player.position.x) {
                                // Opponent is to the left of player
                                newX = player.position.x - minDistance;
                            } else {
                                // Opponent is to the right of player
                                newX = player.position.x + minDistance;
                            }
                            // Reverse direction when blocked by player
                            opponent.userData.moveDirection *= -1;
                        } else {
                            actuallyMoving = true;
                        }
                    } else {
                        actuallyMoving = true;
                    }
                    // Apply the adjusted position
                    if (opponent.position.x !== newX) {
                        opponent.position.x = newX;
                    }
                } else {
                    // Reverse direction if hitting boundary
                    opponent.userData.moveDirection *= -1;
                }
                // Walking animation state logic (mirrors player)
                const shouldBeWalking = (actuallyMoving && !opponent.userData.attacking && !opponent.userData.jumping && moveDirection !== 0);
                if (shouldBeWalking && (!opponent.userData.isWalking || opponent.userData.walkingDirection !== moveDirection)) {
                    opponent.userData.isWalking = true;
                    opponent.userData.walkingDirection = moveDirection;
                    opponent.userData.currentWalkingFrame = 0;
                    opponent.userData.walkingTimer = 0;
                    console.log(`[WALKING ANIM] (Opponent) Started walking in direction: ${moveDirection}`);
                } else if (!shouldBeWalking && opponent.userData.isWalking) {
                    opponent.userData.isWalking = false;
                    opponent.userData.walkingDirection = 0;
                    console.log('[WALKING ANIM] (Opponent) Stopped walking intent');
                }
            }
            
            // Process attack timer
            if (opponent.userData.attacking) {
                opponent.userData.attackTimer -= deltaTime * 1000;
                if (opponent.userData.attackTimer <= 0) {
                    opponent.userData.attacking = false;
                    // Reset hit flag when attack ends
                    opponent.userData.hitThisAttack = false;
                    // For punches, check hit at the end
                    if (player && opponent.userData.attackType === 'punch') {
                        checkAttackHit(opponent, player);
                    }
                }
            }
            
            // Always ensure attacking state is false when not kicking
            if (!opponent.userData.isKicking && opponent.userData.attacking) {
                opponent.userData.attacking = false;
            }
            
            updateHealthBar(false, opponent.userData.health);
        }

        function checkAttackHit(attacker, target) {
            // For kicks, we check during the kick animation, not just when attacking flag is set
            if (!attacker || !target || !attacker.userData || !target.userData) {
                console.log('Hit check failed: missing character data');
                return false;
            }
            
            // Make sure we're either attacking or kicking
            if (!attacker.userData.attacking && !attacker.userData.isKicking) {
                console.log('Hit check failed: character not attacking or kicking');
                return false;
            }
            
            // Initialize all tracking objects if they don't exist
            if (attacker.userData.hitThisAttack === undefined) {
                attacker.userData.hitThisAttack = false;
            }
            
            if (!attacker.userData.hitThisFrame) {
                attacker.userData.hitThisFrame = {};
            }
            
            if (!attacker.userData.hitByFrame) {
                attacker.userData.hitByFrame = {};
            }
            
            // Make sure attackType is properly set for both characters
            const attackType = attacker.userData.isKicking ? 'kick' : (attacker.userData.attackType || 'punch');
            
            // Ensure both characters use the same damage values regardless of who is attacking
            const damage = (attackType === 'punch') ? CONFIG.ATTACK.punchDamage : CONFIG.ATTACK.kickDamage;
            
            // Get current animation frame based on attack type
            const currentFrame = attacker.userData.isKicking ? 
                attacker.userData.currentKickFrame || 0 : 
                attacker.userData.currentPunchFrame || 0;
            
            // Calculate distance based on X and Y only, ignoring Z
            const dx = attacker.position.x - target.position.x;
            const dy = attacker.position.y - target.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const reach = (attackType === 'punch') ? CONFIG.ATTACK.punchReach : CONFIG.ATTACK.kickReach;
            
            console.log(`Attack check: ${attacker.userData.id} (${attackType}) -> ${target.userData.id}, distance: ${distance.toFixed(2)}, reach: ${reach}, frame: ${currentFrame}`);
            console.log(`Hit tracking: hitThisAttack=${attacker.userData.hitThisAttack}, hitByFrame[${currentFrame}]=${attacker.userData.hitByFrame[currentFrame]}`);
            
            // For kicks, use frame-specific hit tracking; for punches, use the global hitThisAttack flag
            const canAttemptHit = attacker.userData.isKicking ? 
                !attacker.userData.hitByFrame[currentFrame] : 
                !attacker.userData.hitThisAttack;
            
            // Only proceed if we haven't hit on this attack/frame yet and we're within reach
            if (distance < reach && canAttemptHit) {
                console.log('Distance check passed, performing collision detection');
                
                // For kicks, check if we're in the right animation frames for a hit (frames 3-9 are the extended kick)
                let canHit = true;
                if (attackType === 'kick' && attacker.userData.isKicking) {
                    canHit = currentFrame >= 3 && currentFrame <= 9;
                    console.log(`Kick frame check: ${currentFrame}, can hit: ${canHit}`);
                }
                
                if (canHit) {
                    // Use pixel-based collision detection
                    if (detectPixelCollision(attacker, target)) {
                        // Check if target is blocking
                        if (target.userData.blocking) {
                            console.log(`ATTACK BLOCKED: ${target.userData.id} blocked ${attackType} from ${attacker.userData.id} on frame ${currentFrame}!`);
                            // No damage is applied when blocking
                            
                            // Still count this as a hit for animation purposes
                            attacker.userData.hitThisAttack = true;
                            if (attacker.userData.isKicking) {
                                attacker.userData.hitByFrame[currentFrame] = true;
                                attacker.userData.hitThisFrame[currentFrame] = true;
                            }
                            
                            // Optional: Add visual or sound effect for successful block
                            // For now, we'll just show a different hit effect
                            showBlockEffect(target);
                            
                            return true; // Hit was detected but blocked
                        }
                        
                        console.log(`HIT CONFIRMED: ${attacker.userData.id} hit ${target.userData.id} with ${attackType} for ${damage} damage on frame ${currentFrame}!`);

                        // Apply damage (only if not blocking)
                        target.userData.health -= damage;
                        target.userData.health = Math.max(0, target.userData.health);
                        
                        // Update hit tracking - use frame-specific tracking for kicks
                        if (attacker.userData.isKicking) {
                            // Mark this specific frame as having hit
                            attacker.userData.hitByFrame[currentFrame] = true;
                            attacker.userData.hitThisFrame[currentFrame] = true;
                            console.log(`Frame-specific hit registered for ${attacker.userData.id} on frame ${currentFrame}`);
                        } 
                        
                        // Always mark the global hit flag for both kick and punch
                        attacker.userData.hitThisAttack = true;
                        
                        target.userData.lastHitTime = clock.getElapsedTime(); // Record hit time
                        
                        // Visual feedback for hit
                        showHitEffect(target);
                        
                        // Update health bar
                        updateHealthBar(target.userData.id === 'player', target.userData.health);

                        // Check for win/loss condition
                        if (target.userData.health <= 0) {
                            if(target.userData.id === 'opponent') {
                                console.log("Player wins!");
                                playerWon = true;
                                setupEnding();
                            } else { // Opponent wins (target is player)
                                console.log("Opponent wins! Going to end screen.");
                                playerWon = false;
                                setupEnding(); 
                            }
                        }
                        
                        return true; // Hit was successful
                    } else {
                        console.log('No pixel collision detected - attack missed');
                    }
                }
            }
            
            return false; // No hit occurred
        }

        // Visual feedback for hit detection
        function showHitEffect(target) {
            if (!target || !target.userData || !target.userData.body) return;
            
            // Store the original color if not already stored
            if (!target.userData.originalColor) {
                target.userData.originalColor = new THREE.Color(1, 1, 1); // Default white
            }
            
            // Flash the character red briefly
            target.userData.body.material.color.set(0xff0000); // Red
            target.userData.body.material.needsUpdate = true;
            
            // Clear any existing timeout to prevent conflicts
            if (target.userData.hitEffectTimeout) {
                clearTimeout(target.userData.hitEffectTimeout);
            }
            
            // Reset color after a short delay
            target.userData.hitEffectTimeout = setTimeout(() => {
                if (target && target.userData && target.userData.body) {
                    target.userData.body.material.color.copy(target.userData.originalColor);
                    target.userData.body.material.needsUpdate = true;
                    console.log(`Reset color for ${target.userData.id}`);
                }
            }, 200); // 200ms flash
            
            // Log hit for debugging
            console.log(`HIT CONFIRMED on ${target.userData.id}! Current health: ${target.userData.health}`);
        }

        // Visual feedback for successful block
        function showBlockEffect(target) {
            if (!target || !target.userData || !target.userData.body) return;
            
            // Store the original color if not already stored
            if (!target.userData.originalColor) {
                target.userData.originalColor = new THREE.Color(1, 1, 1); // Default white
            }
            
            // Flash the character blue briefly to indicate successful block
            target.userData.body.material.color.set(0x0088ff); // Blue
            target.userData.body.material.needsUpdate = true;
            
            // Clear any existing timeout to prevent conflicts
            if (target.userData.blockEffectTimeout) {
                clearTimeout(target.userData.blockEffectTimeout);
            }
            
            // Reset color after a short delay
            target.userData.blockEffectTimeout = setTimeout(() => {
                if (target && target.userData && target.userData.body) {
                    target.userData.body.material.color.copy(target.userData.originalColor);
                    target.userData.body.material.needsUpdate = true;
                    console.log(`Reset color for ${target.userData.id} after block`);
                }
            }, 200); // 200ms flash
            
            // Log block for debugging
            console.log(`BLOCK SUCCESSFUL by ${target.userData.id}!`);
        }

        // --- Animations (Ensure check for character existence) ---
         function updateIntroAnimation(deltaTime) {
            const now = clock.getElapsedTime();

            // Text fade
            if (introText && player && player.userData) { // Ensure objects exist
                 if (introText.material.opacity < 1 && player.userData.introFadeInTimer && now >= player.userData.introFadeInTimer) {
                     introText.material.opacity = Math.min(1, introText.material.opacity + deltaTime / (CONFIG.ANIMATION.textFadeTime / 1000));
                     if (introText.material.opacity >= 1) player.userData.introHoldTimer = now + CONFIG.ANIMATION.introHoldTime / 1000;
                 } else if (introText.material.opacity > 0 && player.userData.introHoldTimer && now >= player.userData.introHoldTimer) {
                     introText.material.opacity = Math.max(0, introText.material.opacity - deltaTime / (CONFIG.ANIMATION.textFadeTime / 1000));
                 }
            }

            // Character Kick
            if (player && player.userData && player.userData.introAnim && player.userData.rightLegUpper) {
                const anim = player.userData.introAnim;
                const leg = player.userData.rightLegUpper;
                const kickSpeed = CONFIG.ANIMATION.introKickSpeed;
                const maxRotation = -Math.PI / 4;

                if (anim.kicking) {
                    leg.rotation.x = Math.max(maxRotation, leg.rotation.x - kickSpeed);
                    if (leg.rotation.x <= maxRotation) { anim.kicking = false; anim.returning = true; }
                } else if (anim.returning) {
                    leg.rotation.x = Math.min(0, leg.rotation.x + kickSpeed * 1.5);
                    if (leg.rotation.x >= 0) anim.returning = false; // Stop animation
                }
            }
        }

        function updateEndingAnimation(deltaTime) {
            const now = clock.getElapsedTime();

            // Text Fade
            if (endText && player && player.userData) { // Ensure objects exist
                if (endText.material.opacity < 1 && player.userData.endFadeInTimer && now >= player.userData.endFadeInTimer) {
                     endText.material.opacity = Math.min(1, endText.material.opacity + deltaTime / (CONFIG.ANIMATION.textFadeTime / 1000));
                }
            }

            // Victory Pose
            if (player && player.userData && player.userData.victoryAnim && player.userData.leftArmUpper && player.userData.rightArmUpper) {
                const anim = player.userData.victoryAnim;
                const leftArm = player.userData.leftArmUpper;
                const rightArm = player.userData.rightArmUpper;
                const poseSpeed = CONFIG.ANIMATION.victoryPoseSpeed;
                const maxRotation = -Math.PI / 3; // Raise arms higher

                if (anim.raising) {
                     leftArm.rotation.x = Math.max(maxRotation, leftArm.rotation.x - poseSpeed);
                     rightArm.rotation.x = Math.max(maxRotation, rightArm.rotation.x - poseSpeed); // Match left arm logic
                     if (leftArm.rotation.x <= maxRotation) {
                         anim.raising = false; anim.holding = true; anim.holdTimer = now + 1.5; // Hold longer
                     }
                 } else if (anim.holding && now >= anim.holdTimer) {
                     anim.holding = false; anim.returning = true; // Add returning state
                 } else if (anim.returning) {
                     leftArm.rotation.x = Math.min(0, leftArm.rotation.x + poseSpeed * 1.5);
                     rightArm.rotation.x = Math.min(0, rightArm.rotation.x + poseSpeed * 1.5);
                     if (leftArm.rotation.x >= 0) {
                         anim.returning = false; // Stop returning
                         // Optional: restart anim.raising = true;
                     }
                 }
            }

            // Confetti - only update if in ending state
            if (gameState === 'ending') {
                confetti.forEach(particle => {
                    if (particle && particle.userData && particle.userData.velocity) {
                        particle.position.add(particle.userData.velocity);
                        particle.rotation.x += Math.random() * 0.1;
                        particle.rotation.y += Math.random() * 0.1;
                        if (particle.position.y < CONFIG.CONFETTI.despawnY) {
                            particle.position.set( (Math.random() - 0.5) * CONFIG.ARENA.width * 0.8, CONFIG.CONFETTI.spawnY + Math.random(), (Math.random() - 0.5) * 2 );
                            particle.userData.velocity.y = -CONFIG.CONFETTI.fallSpeed * (0.8 + Math.random() * 0.4);
                        }
                    }
                });
            }
         }

        function updateJumpAnimation(character, deltaTime) {
            if (!character || !character.userData || !character.userData.body) return;
            
            if (character.userData.jumping) {
                const body = character.userData.body;
                const jumpTextures = character.userData.jumpTextures;
                // Update frame based on vertical position and velocity
                if (character.position.y > 0.5) {
                    // In air - use second frame
                    body.material.map = jumpTextures[1];
                } else if (character.position.y > 0) {
                    // Initial jump or landing - use first frame
                    body.material.map = jumpTextures[0];
                }
                // Note: We don't set standing texture here - it's handled in updatePlayer
                // when character actually lands (position.y <= GROUND_Y)
                body.material.needsUpdate = true;
            } else if (character.position.y === GROUND_Y) {
                // Safety check - ensure standing texture when on ground
                character.userData.body.material.map = character.userData.standingTexture;
                character.userData.body.material.needsUpdate = true;
            }
        }

        // Walking animation logic (restored and separated)
        function updateWalkingAnimation(character, deltaTime) {
            if (!character || !character.userData || !character.userData.body || !character.userData.walkingTextures || character.userData.walkingTextures.length === 0) {
                //console.log('[WALKING ANIM] Update skipped: Missing data or textures');
                return;
            }
            // Reset to standing if not walking, jumping, kicking, punching, or blocking
            if (!character.userData.isWalking && !character.userData.jumping && !character.userData.isKicking && !character.userData.isPunching && !character.userData.blocking) {
                if (character.userData.body.material.map !== character.userData.standingTexture) {
                    character.userData.body.material.map = character.userData.standingTexture;
                    character.userData.body.material.needsUpdate = true;
                }
                return; // Exit if not walking
            }
            // Check if character just stopped walking but is still blocking
            if (!character.userData.isWalking && character.userData.blocking && character.userData.blockTexture) {
                // If we were walking and now we're blocking, restore the block texture
                if (character.userData.body.material.map !== character.userData.blockTexture) {
                    character.userData.body.material.map = character.userData.blockTexture;
                    character.userData.body.material.needsUpdate = true;
                }
                return; // Exit after restoring block texture
            }
            
            // Only proceed if actually walking
            if (character.userData.isWalking) {
                // Update animation timer
                character.userData.walkingTimer = (character.userData.walkingTimer || 0) + deltaTime;
                // Update frame every 100ms (10fps)
                if (character.userData.walkingTimer >= 0.1) {
                    character.userData.walkingTimer = 0;
                    // Get current frame and calculate next frame
                    const currentFrame = character.userData.currentWalkingFrame || 0;
                    const nextFrame = (currentFrame + 1) % character.userData.walkingTextures.length;
                    // Update frame counter
                    character.userData.currentWalkingFrame = nextFrame;
                    console.log(`[WALKING ANIM] Character ${character.userData.id} walking frame: ${nextFrame+1}/${character.userData.walkingTextures.length}, texture available: ${!!character.userData.walkingTextures[nextFrame]}`);
                    // Apply the texture
                    if (character.userData.walkingTextures && character.userData.walkingTextures.length > 0) {
                        character.userData.body.material.map = character.userData.walkingTextures[nextFrame];
                        character.userData.body.material.needsUpdate = true;
                    }
                    // IMPORTANT: Always make character face the opponent regardless of walking direction
                    const opponent = character.userData.id === 'player' ? window.opponent : window.player;
                    if (opponent) {
                        // Determine if opponent is to the left or right
                        const facingDirection = opponent.position.x > character.position.x ? 1 : -1;
                        
                        // Set scale.x to make character face the opponent - DO NOT change this based on walking direction
                        character.userData.body.scale.x = facingDirection;
                        
                        console.log(`[WALKING ANIM] ${character.userData.id} facing direction: ${facingDirection}, opponent at: ${opponent.position.x.toFixed(2)}, character at: ${character.position.x.toFixed(2)}`);
                    }
                }
            }
        }

        // Punch animation handler
        function updatePunchAnimation(character, deltaTime, targetCharacter) {
    // DEBUG: Punch animation handler called
    if (character && character.userData && character.userData.id) {
        console.log(`[PUNCH DEBUG] updatePunchAnimation called for ${character.userData.id}. isPunching=${character.userData.isPunching}, currentPunchFrame=${character.userData.currentPunchFrame}, punchTimer=${character.userData.punchTimer}`);
    }
            if (!character || !character.userData || !character.userData.body || !character.userData.isPunching) return;
            // Animation timing
            const punchFrames = character.userData.punchTextures.length;
            const punchDuration = CONFIG.ATTACK.punchDuration;
            const frameDuration = punchDuration / punchFrames;
            character.userData.punchTimer = (character.userData.punchTimer || 0) + deltaTime * 1000;
            let frame = Math.floor(character.userData.punchTimer / frameDuration);
    // DEBUG: Calculated punch frame
    if (character && character.userData) {
        console.log(`[PUNCH DEBUG] Frame calculation: punchTimer=${character.userData.punchTimer}, frameDuration=${frameDuration}, frame=${frame}`);
    }
            if (frame >= punchFrames) frame = punchFrames - 1;
    // DEBUG: Frame after clamp
    if (character && character.userData) {
        console.log(`[PUNCH DEBUG] Frame after clamp: frame=${frame}, punchFrames=${punchFrames}`);
    }
            character.userData.currentPunchFrame = frame;
            // Set punch frame texture
            character.userData.body.material.map = character.userData.punchTextures[frame];
            character.userData.body.material.needsUpdate = true;

            // Ensure punch is considered an attack for hit checks
            character.userData.attacking = true;

            // --- Punch hit detection logic ---
            // Only allow one hit per punch
            if (frame >= 3 && frame <= 5 && !character.userData.hitThisAttack && targetCharacter) {
                console.log(`${character.userData.id} checking for punch hit on frame ${frame}`);
                const hitLanded = checkAttackHit(character, targetCharacter);
                if (hitLanded) {
                    console.log(`Hit landed for ${character.userData.id} with punch on frame ${frame}`);
                }
            }
            // End animation
            if (character.userData.punchTimer >= punchDuration) {
        console.log(`[PUNCH DEBUG] Punch animation finished for ${character.userData.id}`);
                character.userData.isPunching = false;
                character.userData.attacking = false;
                character.userData.punchTimer = 0;
                character.userData.currentPunchFrame = 0;
                // Restore standing texture
                character.userData.body.material.map = character.userData.standingTexture;
                character.userData.body.material.needsUpdate = true;
                // Reset all hit tracking flags
                character.userData.hitThisAttack = false;
                character.userData.hitByFrame = {};
                character.userData.hitThisFrame = {};
            }
        }
        // Added targetCharacter parameter
        function updateKickAnimation(player, deltaTime, targetCharacter) {
            if (!player || !player.userData || !player.userData.body) {
                return;
            }

            // Initialize tracking objects if they don't exist
            if (!player.userData.hitThisFrame) player.userData.hitThisFrame = {};
            if (!player.userData.hitByFrame) player.userData.hitByFrame = {};

            // Debug kick animation state if needed
            if (player.userData.id === 'opponent' && player.userData.isKicking && !player.userData.kickDebugLogged) {
                console.log('Opponent kick animation active:', {
                    currentKickFrame: player.userData.currentKickFrame,
                    kickTextures: player.userData.kickTextures ? player.userData.kickTextures.length : 0,
                    kickTimer: player.userData.kickTimer
                });
                player.userData.kickDebugLogged = true;
            }
            
            if (player.userData.isKicking) {
                player.userData.kickTimer += deltaTime;
                
                // Update frame every 50ms (20fps)
                if (player.userData.kickTimer >= 0.05) {
                    player.userData.kickTimer = 0;
                    
                    // Store previous frame for comparison
                    const previousFrame = player.userData.currentKickFrame;
                    player.userData.currentKickFrame++;
                    
                    // Reset hit tracking at the start of animation
                    if (player.userData.currentKickFrame === 1) {
                        console.log(`Resetting hit tracking at start of kick animation for ${player.userData.id}`);
                        player.userData.hitThisAttack = false;
                        player.userData.hitByFrame = {};
                        player.userData.hitThisFrame = {};
                    }
                    
                    console.log(`${player.userData.id} kick frame: ${player.userData.currentKickFrame}/${player.userData.kickTextures.length}`);
                    
                    if (player.userData.currentKickFrame < player.userData.kickTextures.length) {
                        // Show next frame
                        player.userData.body.material.map = 
                            player.userData.kickTextures[player.userData.currentKickFrame];
                        player.userData.body.material.needsUpdate = true;
                        
                        // Make sure attacking state stays true during kick animation
                        // This ensures hit detection works throughout the animation
                        player.userData.attacking = true;
                        
                        // Check for hits on frames 3-7 which are the active kick frames
                        // This ensures more consistent hit opportunities
                        if (player.userData.currentKickFrame >= 3 && player.userData.currentKickFrame <= 7) {
                            console.log(`${player.userData.id} checking for kick hit on frame ${player.userData.currentKickFrame}`);
                            
                            // Check for hit using the passed targetCharacter
                            if (targetCharacter) {
                                // Only check for hit once per specific frame
                                if (!player.userData.hitThisFrame[player.userData.currentKickFrame]) {
                                    console.log(`${player.userData.id} performing hit check on frame ${player.userData.currentKickFrame}`);
                                    const hitLanded = checkAttackHit(player, targetCharacter);
                                    
                                    // Mark this frame as checked regardless of hit result
                                    player.userData.hitThisFrame[player.userData.currentKickFrame] = true;
                                    
                                    if (hitLanded) {
                                        console.log(`Hit landed for ${player.userData.id} on frame ${player.userData.currentKickFrame}`);
                                    }
                                }
                            }
                        }
                    } else {
                        // Animation complete
                        console.log(`${player.userData.id} kick animation complete`);
                        player.userData.isKicking = false;
                        player.userData.attacking = false; // Reset attacking state immediately
                        player.userData.body.material.map = player.userData.standingTexture;
                        player.userData.body.material.needsUpdate = true;
                        player.userData.kickDebugLogged = false; // Reset debug flag
                        
                        // Reset ALL hit tracking flags
                        player.userData.hitThisAttack = false;
                        player.userData.hitByFrame = {};
                        player.userData.hitThisFrame = {};
                        console.log(`Complete hit tracking reset for ${player.userData.id} at end of animation`);
                    }
                }
            }
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            
            // Update billboarding for characters to always face camera
            scene.traverse(function(object) {
                if (object.userData && object.userData.isBillboard) {
                    object.quaternion.copy(camera.quaternion);
                }
            });

            // Always update animations regardless of game state if objects exist
            if (gameState === 'intro') updateIntroAnimation(deltaTime);
            if (gameState === 'ending') updateEndingAnimation(deltaTime);

            // Update punch animations before kick/walking animations
            if (player && player.userData.isPunching) updatePunchAnimation(player, deltaTime, opponent);
            if (opponent && opponent.userData.isPunching) updatePunchAnimation(opponent, deltaTime, player);
            // Update kick animations before walking animations (prioritizes kicks)
            // Pass the correct target character
            if (player && player.userData.isKicking) updateKickAnimation(player, deltaTime, opponent);
            if (opponent && opponent.userData.isKicking) updateKickAnimation(opponent, deltaTime, player);
            
            // Update jump animations after kick animations
            if (player && player.userData.jumping) updateJumpAnimation(player, deltaTime);
            if (opponent && opponent.userData.jumping) updateJumpAnimation(opponent, deltaTime);
            
            // Update Walking Animations (AFTER jump/kick/punch, BEFORE render)
            // Only update walking animation if not punching, kicking, or jumping
            if (player && !player.userData.isKicking && !player.userData.jumping && !player.userData.isPunching) updateWalkingAnimation(player, deltaTime);
            if (opponent && !opponent.userData.isKicking && !opponent.userData.jumping && !opponent.userData.isPunching) updateWalkingAnimation(opponent, deltaTime);
            
            // Update gameplay logic only in gameplay state
            if (gameState === 'gameplay') {
                updatePlayer(deltaTime); // Determines player state (like isWalking)
                updateOpponent(deltaTime);
            }

            // Clear both the color buffer and depth buffer before rendering
            renderer.clear(true, true, true);
            renderer.render(scene, camera);
        }

        // --- Audio Functions ---
        function initAudio() {
            // Create audio element for background music
            backgroundMusic = new Audio('assets/audio/09. Ryu Stage.mp3');
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.7; // 70% volume
            
            // Add a click event listener to the document to enable audio
            // This helps with browsers that require user interaction
            document.addEventListener('click', function() {
                // This empty function just ensures we have user interaction
                // before trying to play any audio
            }, { once: true });
        }
        
        function playBackgroundMusic() {
            // Play background music if it exists
            if (backgroundMusic) {
                // Reset to beginning if it was already playing
                backgroundMusic.currentTime = 0;
                
                // Play the music with a user interaction (this is required by browsers)
                const playPromise = backgroundMusic.play();
                
                // Handle potential play() promise rejection
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.error('Audio playback failed:', error);
                    });
                }
                
                console.log('Background music started');
            }
        }
        
        function stopBackgroundMusic() {
            if (backgroundMusic && !backgroundMusic.paused) {
                backgroundMusic.pause();
                console.log('Background music stopped');
            }
        }
        
        // Extract pixel data from textures for collision detection
        function extractTextureData(texture, name) {
            // Wait for the image to load
            if (!texture.image || !texture.image.complete) {
                texture.addEventListener('load', function() {
                    extractTextureDataFromImage(texture.image, name);
                });
                return;
            }
            
            extractTextureDataFromImage(texture.image, name);
        }
        
        function extractTextureDataFromImage(image, name) {
            // Create a canvas to draw the image
            const canvas = document.createElement('canvas');
            canvas.width = image.width;
            canvas.height = image.height;
            
            // Draw the image onto the canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0);
            
            try {
                // Get the pixel data
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Count non-transparent pixels to verify texture data is valid
                let nonTransparentCount = 0;
                for (let i = 3; i < imageData.data.length; i += 4) {
                    if (imageData.data[i] > 50) nonTransparentCount++;
                }
                
                // Store the pixel data and dimensions
                texturePixelData[name] = {
                    data: imageData.data,
                    width: canvas.width,
                    height: canvas.height
                };
                
                console.log(`Extracted pixel data for texture: ${name}, dimensions: ${canvas.width}x${canvas.height}, non-transparent pixels: ${nonTransparentCount}`);
            } catch (e) {
                console.error(`Failed to extract pixel data for ${name}:`, e);
            }
        }
        
        // Detect pixel-level collision between two characters
        function detectPixelCollision(attacker, target) {
            // Get the current textures being used
            const attackerTexture = attacker.userData.body.material.map;
            const targetTexture = target.userData.body.material.map;
            
            if (!attackerTexture || !targetTexture) {
                console.log('Collision detection failed: missing textures');
                return false;
            }
            
            // Get the texture names
            let attackerTextureName = 'standing';
            let targetTextureName = 'standing';
            
            // Determine attacker texture name
            if (attacker.userData.isKicking) {
                attackerTextureName = `kick-${(attacker.userData.currentKickFrame + 1).toString().padStart(3, '0')}`;
            } else if (attacker.userData.isJumping) {
                attackerTextureName = `jump-${Math.min(attacker.userData.currentJumpFrame + 1, 2).toString().padStart(3, '0')}`;
            }
            
            // Determine target texture name
            if (target.userData.isKicking) {
                targetTextureName = `kick-${(target.userData.currentKickFrame + 1).toString().padStart(3, '0')}`;
            } else if (target.userData.isJumping) {
                targetTextureName = `jump-${Math.min(target.userData.currentJumpFrame + 1, 2).toString().padStart(3, '0')}`;
            }
            
            console.log(`Checking collision: ${attackerTextureName} vs ${targetTextureName}`);
            console.log('Available texture data keys:', Object.keys(texturePixelData));
            
            // Get pixel data
            let attackerData = texturePixelData[attackerTextureName];
            let targetData = texturePixelData[targetTextureName];
            
            if (!attackerData || !targetData) {
                console.log(`Collision detection failed: missing pixel data for ${!attackerData ? attackerTextureName : ''} ${!targetData ? targetTextureName : ''}`);
                
                // If we're missing data for the specific frame, fall back to standing texture
                if (!attackerData && attackerTextureName !== 'standing') {
                    console.log(`Trying fallback to standing texture for attacker`);
                    attackerData = texturePixelData['standing'];
                }
                if (!targetData && targetTextureName !== 'standing') {
                    console.log(`Trying fallback to standing texture for target`);
                    targetData = texturePixelData['standing'];
                }
                
                // If still no data, return false
                if (!attackerData || !targetData) {
                    return false;
                }
            }
            
            // Calculate character positions in world space
            const attackerWorldPos = new THREE.Vector3();
            const targetWorldPos = new THREE.Vector3();
            attacker.getWorldPosition(attackerWorldPos);
            target.getWorldPosition(targetWorldPos);
            
            // Calculate the overlap region between the two sprites
            // Use actual geometry dimensions
            const attackerWidth = attacker.userData.body.geometry.parameters.width;
            const attackerHeight = attacker.userData.body.geometry.parameters.height;
            const targetWidth = target.userData.body.geometry.parameters.width;
            const targetHeight = target.userData.body.geometry.parameters.height;
            
            // Calculate ORIGINAL world space boundaries (used for texture mapping)
            const origAttackerLeft = attackerWorldPos.x - attackerWidth/2;
            const origAttackerRight = attackerWorldPos.x + attackerWidth/2;
            const origAttackerTop = attackerWorldPos.y + attackerHeight/2;
            const origAttackerBottom = attackerWorldPos.y - attackerHeight/2;

            const origTargetLeft = targetWorldPos.x - targetWidth/2;
            const origTargetRight = targetWorldPos.x + targetWidth/2;
            const origTargetTop = targetWorldPos.y + targetHeight/2;
            const origTargetBottom = targetWorldPos.y - targetHeight/2;

            console.log(`Attacker Original Bounds: L=${origAttackerLeft.toFixed(2)}, R=${origAttackerRight.toFixed(2)}, T=${origAttackerTop.toFixed(2)}, B=${origAttackerBottom.toFixed(2)}`);
            console.log(`Target Original Bounds: L=${origTargetLeft.toFixed(2)}, R=${origTargetRight.toFixed(2)}, T=${origTargetTop.toFixed(2)}, B=${origTargetBottom.toFixed(2)}`);

            // Calculate potentially extended boundaries for overlap check during kicks
            let overlapCheckAttackerLeft = origAttackerLeft;
            let overlapCheckAttackerRight = origAttackerRight;
            // Use original top/bottom for overlap check as kick extends horizontally
            const overlapCheckAttackerTop = origAttackerTop;
            const overlapCheckAttackerBottom = origAttackerBottom;

            if (attacker.userData.isKicking && attacker.userData.currentKickFrame >= 3 && attacker.userData.currentKickFrame <= 9) {
                // Extend the attacker's bounding box in the direction they're facing
                const extendAmount = 2.0; // Extend by 2.0 units for better hit detection
                
                // Determine which direction to extend based on character orientation
                // For opponent (who is flipped), we need to reverse the direction
                console.log(`Extending kick box: attacker=${attacker.userData.id}, positions: attacker=${attacker.position.x.toFixed(2)}, target=${target.position.x.toFixed(2)}`);
                
                if ((attacker.position.x < target.position.x)) {
                    // Extend right
                    overlapCheckAttackerRight = origAttackerRight + extendAmount;
                    console.log(`Extended kick bounding box RIGHT: L=${overlapCheckAttackerLeft.toFixed(2)}, R=${overlapCheckAttackerRight.toFixed(2)}`);
                } else {
                    // Extend left
                    overlapCheckAttackerLeft = origAttackerLeft - extendAmount;
                    console.log(`Extended kick bounding box LEFT: L=${overlapCheckAttackerLeft.toFixed(2)}, R=${overlapCheckAttackerRight.toFixed(2)}`);
                }
            }

            // Check if bounding boxes overlap (using extended attacker box and original target box)
            if (overlapCheckAttackerRight < origTargetLeft || overlapCheckAttackerLeft > origTargetRight ||
                overlapCheckAttackerBottom > origTargetTop || overlapCheckAttackerTop < origTargetBottom) {
                console.log('No bounding box overlap detected');
                return false; // No collision possible
            }
            
            console.log('Bounding boxes overlap, checking pixel collision');

            // Calculate overlap region using extended attacker and original target bounds for iteration
            const overlapLeft = Math.max(overlapCheckAttackerLeft, origTargetLeft);
            const overlapRight = Math.min(overlapCheckAttackerRight, origTargetRight);
            const overlapTop = Math.min(overlapCheckAttackerTop, origTargetTop);
            const overlapBottom = Math.max(overlapCheckAttackerBottom, origTargetBottom);

            console.log(`Overlap region (World Coords): L=${overlapLeft.toFixed(2)}, R=${overlapRight.toFixed(2)}, T=${overlapTop.toFixed(2)}, B=${overlapBottom.toFixed(2)}`);

            const worldStep = 0.1; // Sample every 0.1 world units in the overlap
            let overlappingPixelChecks = 0;

            // Iterate through the world-space overlap region
            for (let worldY = overlapBottom; worldY < overlapTop; worldY += worldStep) {
                for (let worldX = overlapLeft; worldX < overlapRight; worldX += worldStep) {
                    overlappingPixelChecks++;

                    // --- Calculate Attacker Texture Coordinate (using ORIGINAL bounds) ---
                    const normXA = (worldX - origAttackerLeft) / attackerWidth;
                    const normYA = (origAttackerTop - worldY) / attackerHeight; // Y is inverted
                    const attackerTexX = Math.floor( (attacker.userData.body.scale.x < 0 ? (1 - normXA) : normXA) * attackerData.width );
                    const attackerTexY = Math.floor( normYA * attackerData.height );

                    // --- Calculate Target Texture Coordinate (using ORIGINAL bounds) ---
                    const normXT = (worldX - origTargetLeft) / targetWidth;
                    const normYT = (origTargetTop - worldY) / targetHeight; // Y is inverted
                    const targetTexX = Math.floor( (target.userData.body.scale.x < 0 ? (1 - normXT) : normXT) * targetData.width );
                    const targetTexY = Math.floor( normYT * targetData.height );

                    // --- Bounds Check (Texture Coordinates) ---
                    if (attackerTexX < 0 || attackerTexX >= attackerData.width || attackerTexY < 0 || attackerTexY >= attackerData.height ||
                        targetTexX < 0 || targetTexX >= targetData.width || targetTexY < 0 || targetTexY >= targetData.height) {
                        continue; // Skip pixels outside texture bounds
                    }

                    // --- Alpha Check ---
                    const attackerPixelIndex = (attackerTexY * attackerData.width + attackerTexX) * 4 + 3; // Alpha channel
                    const targetPixelIndex = (targetTexY * targetData.width + targetTexX) * 4 + 3; // Alpha channel

                    if (attackerData.data[attackerPixelIndex] > 50 && targetData.data[targetPixelIndex] > 50) {
                         // Log the exact point of collision
                        console.log(`Pixel collision DETECTED at world(${worldX.toFixed(2)},${worldY.toFixed(2)}) -> attacker(${attackerTexX},${attackerTexY})[A:${attackerData.data[attackerPixelIndex]}] & target(${targetTexX},${targetTexY})[A:${targetData.data[targetPixelIndex]}]`);
                        return true; // Collision detected!
                    }
                }
            }

            console.log(`Collision check stats: Checked ${overlappingPixelChecks} world points.`);
            console.log('No pixel collision detected');
            return false; // No collision
        }
        
        // Function to set up HTML mobile controls
        function setupHTMLMobileControls() {
            const mobileControls = document.getElementById('mobile-controls');
            const instructionsDiv = document.getElementById('instructions');
            
            // More reliable mobile detection - force desktop to hide controls
            const isMobileDevice = ('ontouchstart' in window) || 
                                  (navigator.maxTouchPoints > 0) || 
                                  /Android|iPhone|iPad|iPod|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Force hide controls on desktop browsers
            if (!isMobileDevice) {
                mobileControls.style.display = 'none';
                // Also add a style to ensure it's really hidden
                mobileControls.style.visibility = 'hidden';
                mobileControls.style.opacity = '0';
                mobileControls.style.pointerEvents = 'none';
                console.log('Desktop browser detected, mobile controls disabled');
                return;
            }
            
            // Hide instructions div on mobile devices
            if (instructionsDiv) {
                instructionsDiv.style.display = 'none';
                console.log('Mobile device detected, hiding instructions');
            }
            
            // Left button - move left
            document.getElementById('btn-left').addEventListener('touchstart', function(e) {
                e.preventDefault();
                keysPressed['MobileLeft'] = true;
            });
            document.getElementById('btn-left').addEventListener('touchend', function(e) {
                e.preventDefault();
                keysPressed['MobileLeft'] = false;
            });
            
            // Right button - move right
            document.getElementById('btn-right').addEventListener('touchstart', function(e) {
                e.preventDefault();
                keysPressed['MobileRight'] = true;
            });
            document.getElementById('btn-right').addEventListener('touchend', function(e) {
                e.preventDefault();
                keysPressed['MobileRight'] = false;
            });
            
            // Jump button
            document.getElementById('btn-jump').addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (gameState === 'gameplay') {
                    handleJumpInput('player');
                }
            });
            
            // Punch button
            document.getElementById('btn-punch').addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (gameState === 'gameplay') {
                    handleAttackInput('player', 'punch');
                }
            });

            // Block button (touchstart = block ON, touchend = block OFF)
            document.getElementById('btn-block').addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (gameState === 'gameplay') {
                    player.userData.blocking = true;
                    // Set block texture for visual feedback
                    if (player.userData.blockTexture) {
                        player.userData.body.material.map = player.userData.blockTexture;
                        player.userData.body.material.needsUpdate = true;
                    }
                }
            });
            document.getElementById('btn-block').addEventListener('touchend', function(e) {
                e.preventDefault();
                player.userData.blocking = false;
                // Revert to standing texture when block is released
                if (player.userData.standingTexture) {
                    player.userData.body.material.map = player.userData.standingTexture;
                    player.userData.body.material.needsUpdate = true;
                }
            });
            
            // Kick button
            document.getElementById('btn-kick').addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (gameState === 'gameplay') {
                    handleAttackInput('player', 'kick');
                }
            });
            
            // Prevent scrolling when touching the buttons
            document.querySelectorAll('.mobile-control').forEach(btn => {
                btn.addEventListener('touchmove', function(e) {
                    e.preventDefault();
                });
            });
            
            // Show mobile controls during gameplay, hide during other states
            function updateMobileControlsVisibility() {
                if (gameState === 'gameplay') {
                    mobileControls.style.display = 'block';
                } else {
                    mobileControls.style.display = 'none';
                }
            }
            
            // Initial visibility
            updateMobileControlsVisibility();
            
            // Monitor gameState changes to update visibility
            setInterval(updateMobileControlsVisibility, 500);
            
            console.log('Mobile device detected, mobile controls enabled');
        }
        
        // --- Start ---
        init();
        setupHTMLMobileControls();
        
        // Debug log to confirm initialization
        console.log('Game initialized, waiting for gameplay to start');
    </script>
</body>
</html>
