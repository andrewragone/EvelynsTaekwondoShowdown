<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Evelynâ€™s Taekwondo Showdown</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 3px;
            display: none; /* Hidden by default, shown in gameplay */
            z-index: 10; /* Ensure it's above canvas */
        }
        /* Add styles for HTML health bars */
        .health-bar {
            position: fixed;
            top: 10px;
            width: 200px;
            height: 20px;
            border: 2px solid #fff;
            background-color: #333;
            z-index: 10;
            display: none; /* Hidden by default, shown in gameplay */
            overflow: hidden; /* Ensure the fill doesn't overflow */
            border-radius: 5px; /* Rounded corners */
        }
        #player-health-bar {
            left: 10px;
        }
        #opponent-health-bar {
            right: 10px;
        }
        .health-bar-fill {
            width: 100%;
            height: 100%;
            background-color: #f00;
        }
        #player-health-bar-fill {
            transform-origin: right center;
        }
        #opponent-health-bar-fill {
            transform-origin: left center;
        }
    </style>
</head>
<body>
    <div id="instructions">
        Desktop: Arrow Keys (Move/Jump), Spacebar (Attack)<br>
        Mobile: Use On-Screen Buttons
    </div>
    <div id="player-health-bar" class="health-bar">
        <div id="player-health-bar-fill" class="health-bar-fill"></div>
    </div>
    <div id="opponent-health-bar" class="health-bar">
        <div id="opponent-health-bar-fill" class="health-bar-fill"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // --- Configuration ---
        const CONFIG = {
            CAMERA_POS: new THREE.Vector3(0, 2, 6), // Moved camera closer to better frame the skinnier dojo
            CHARACTER: {
                bodyRadius: 0.4, bodyHeight: 1.5,
                headRadius: 0.3,
                shoulderWidth: 0.7,
                armUpperLength: 0.6, armLowerLength: 0.5, armRadius: 0.15,
                legUpperLength: 0.7, legLowerLength: 0.7, legRadius: 0.18,
                beltSize: new THREE.Vector3(0.9, 0.15, 0.45),
                skinColor: 0xf5d7b2,
                giColor: 0xffffff,
                opponentGiColor: 0xff0000,
                beltColor: 0x000000,
                jointColor: 0x333333,
            },
            ARENA: {
                width: 8, // Reduced from 10 to make the dojo skinnier
                floorColor: 0xd3d3d3,
                playerStartX: -2, // Player on left side
                opponentStartX: 2, // Opponent on right side
                boundaryLeft: -3, // Narrower boundaries
                boundaryRight: 3, // Narrower boundaries
            },
            MOVEMENT: {
                speed: 0.15, // Increased from 0.05 to make movement faster
                jumpVelocity: 0.12, // Increased from 0.08 for higher jumps
                gravity: 0.0035, // Slightly reduced for better jump arc
                maxJumpHeight: 2.0, // Increased maximum jump height
            },
            ATTACK: {
                punchReach: 1.2, punchDamage: 10, punchDuration: 300,
                kickReach: 3.0, kickDamage: 15, kickDuration: 500, // Increased reach to allow kicks to connect at safe distance
                cooldown: 0, // Reduced cooldown for more responsive attacks
            },
            AI: {
                moveIntervalMin: 1000, moveIntervalMax: 2000,
                attackIntervalMin: 1500, attackIntervalMax: 3000,
                attackProbability: 0.7,
            },
            HEALTH: {
                max: 100,
                barWidth: 2, barHeight: 0.2, barOffset: 2.5, // Increased from 1.8 to position above heads
                barColor: 0xff0000,
                barBackgroundColor: 0x333333, // Added background color for better visibility
            },
            UI: {
                font: 'bold 32px Arial',
                fontColor: 'white',
                outlineColor: 'black',
                buttonWidth: 1.5, buttonHeight: 0.5,
                mobileButtonSize: 0.8,
                mobileButtonOpacity: 0.7,
            },
            COLORS: {
                introBg: 0x87ceeb,
                gameBg: 0x00008b,
                endBg: 0x800080,
                startButton: 0xff0000,
                playAgainButton: 0x00ff00,
                mobileLeftRight: 0x808080,
                mobileJump: 0xffff00,
                mobilePunch: 0xff0000,
                mobileKick: 0xff6600,
            },
            ANIMATION: {
                textFadeTime: 1000,
                introHoldTime: 3000,
                introKickSpeed: 0.015,
                victoryPoseSpeed: 0.01,
                kickLegUpperRotation: Math.PI / 3,  // Upper leg rotation for kick
                kickLegLowerRotation: -Math.PI / 2, // Lower leg rotation for kick
                punchArmRotation: -Math.PI / 2.5    // Arm rotation for punch
            },
            CONFETTI: {
                count: 50,
                fallSpeed: 0.05,
                spawnY: 5,
                despawnY: -1,
                colors: [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff],
            }
        };

        // --- Global Variables ---
        let scene, camera, renderer, clock;
        let gameState = 'loading'; // loading, intro, gameplay, ending
        let player, opponent;
        let floor;
        let backgroundMusic; // Audio element for background music
        let texturePixelData = {}; // Store pixel data for collision detection
        let introText, startButton, endText, playAgainButton, confetti = [];
        let playerHealthBar, opponentHealthBar;
        let mobileButtons = {};
        let keysPressed = {}; // Store pressed keys/buttons
        let activeMobileInputs = {}; // Track active pointer IDs for mobile buttons
        let backgroundSprite; // New global variable for background sprite

        // Initial player/opponent states
        const initialPlayerState = { jumping: false, velocityY: 0, attacking: false, attackType: 'punch', attackTimer: 0, lastAttackTime: 0, health: CONFIG.HEALTH.max, id: 'player', position: { x: -2 } };
        const initialOpponentState = { attacking: false, attackType: 'punch', attackTimer: 0, moveDirection: 1, nextMoveTime: 0, nextAttackTime: 0, health: CONFIG.HEALTH.max, id: 'opponent', position: { x: 2 } };

        let raycaster, pointer;

        // Define screen boundaries (adjust these values based on your dojo.jpg dimensions)
        const SCREEN_LEFT = -5;  // Left edge of visible area
        const SCREEN_RIGHT = 5;  // Right edge of visible area
        const CHARACTER_HALF_WIDTH = 1; // Half of character width (since scale.x=2)

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(CONFIG.CAMERA_POS);
            camera.lookAt(0, 1, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();
            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();
            
            // Initialize audio
            initAudio();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            // Mobile / Pointer Events
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointerup', onPointerUp);
            renderer.domElement.addEventListener('pointermove', onPointerMove); // Needed to track movement off buttons
            renderer.domElement.addEventListener('pointerleave', onPointerLeave); // Handle pointer leaving canvas

            createMobileControls();
            setupSceneLighting();

            gameState = 'intro';
            setupIntro();

            animate();
        }

        function setupSceneLighting() {
            if (!backgroundSprite) {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load('http://localhost:8000/dojo.jpg', 
                    (texture) => {
                        console.log('Background texture loaded successfully');
                        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                        backgroundSprite = new THREE.Sprite(spriteMaterial);
                        
                        // Increase scale proportionally for zoom effect
                        const zoomFactor = 3; // Adjust this value for desired zoom level
                        backgroundSprite.scale.set(16 * zoomFactor, 9 * zoomFactor, 1);
                        backgroundSprite.position.z = -15; // Move back further to accommodate zoom
                        scene.add(backgroundSprite);
                    },
                    undefined,
                    (err) => console.error('Error loading background texture:', err)
                );
            } else {
                scene.add(backgroundSprite);
            }

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
        }

        // --- State Management & Scene Setup ---
        function clearScene() {
            if (introText) scene.remove(introText);
            if (startButton) scene.remove(startButton);
            if (endText) scene.remove(endText);
            if (playAgainButton) scene.remove(playAgainButton);
            if (floor) scene.remove(floor);
            if (player) scene.remove(player);
            if (opponent) scene.remove(opponent);
            
            // Properly clear all confetti
            confetti.forEach(confetto => {
                scene.remove(confetto);
                // Also dispose of geometries and materials to prevent memory leaks
                if (confetto.geometry) confetto.geometry.dispose();
                if (confetto.material) confetto.material.dispose();
            });
            confetti = [];
            
            // Look for and remove any confetti group
            const confettiGroup = scene.getObjectByName('confettiGroup');
            if (confettiGroup) {
                scene.remove(confettiGroup);
            }
            
            // Don't remove backgroundSprite
            Object.values(mobileButtons).forEach(btn => { btn.visible = false; });
        }

        function setupIntro() {
            clearScene();
            
            // Hide health bars
            document.getElementById('player-health-bar').style.display = 'none';
            document.getElementById('opponent-health-bar').style.display = 'none';
            
            // No intro music, only gameplay music
            
            gameState = 'intro';
            Object.values(mobileButtons).forEach(btn => { btn.visible = false; });

            player = createCharacter(CONFIG.CHARACTER.giColor, true);
            player.position.set(0, 0.75, 0);
            player.userData.introAnim = { kicking: true, legRotation: 0, returning: false };
            scene.add(player);

            const introLines = [
                "Evelyn's Taekwondo Showdown:", "8th Birthday Party Edition", "",
                "Get ready to kick it at UMAC Briarcliff!"
            ];
            introText = createTextMesh(introLines.join('\n'), { x: 0, y: 3, z: 0 }, 0.8, true); // Adjusted scale/pos
            introText.material.opacity = 0;
            scene.add(introText);

            // Create a clickable HTML button instead of a 3D button
            const startButtonHTML = document.createElement('button');
            startButtonHTML.id = 'startFightButton'; // Add ID for easier selection
            startButtonHTML.textContent = 'Start Fight';
            startButtonHTML.style.position = 'absolute';
            startButtonHTML.style.left = '50%';
            startButtonHTML.style.top = '70%';
            startButtonHTML.style.transform = 'translate(-50%, -50%)';
            startButtonHTML.style.padding = '15px 30px';
            startButtonHTML.style.fontSize = '24px';
            startButtonHTML.style.backgroundColor = '#ff0000';
            startButtonHTML.style.color = 'white';
            startButtonHTML.style.border = 'none';
            startButtonHTML.style.borderRadius = '5px';
            startButtonHTML.style.cursor = 'pointer';
            startButtonHTML.style.fontFamily = 'Arial, sans-serif';
            startButtonHTML.style.fontWeight = 'bold';
            startButtonHTML.style.zIndex = '1000';
            startButtonHTML.onclick = function() {
                
                // Remove the button immediately when clicked
                if (startButtonHTML.parentNode) {
                    startButtonHTML.parentNode.removeChild(startButtonHTML);
                }
                startGameplay();
            };

            document.body.appendChild(startButtonHTML);
            
            // Store reference to remove it later
            startButton = startButtonHTML;

            player.userData.introFadeInTimer = clock.getElapsedTime() + 0.1;
            player.userData.introHoldTimer = 0;
            player.userData.introFadeOutTimer = 0;
        }

        function startGameplay() {
            clearScene();
            console.log('Scene cleared for gameplay');
            
            // Remove HTML button if it exists (double-check)
            const startFightButton = document.getElementById('startFightButton');
            if (startFightButton) {
                startFightButton.parentNode.removeChild(startFightButton);
                console.log('Start fight button removed');
            }
            
            gameState = 'gameplay';
            console.log('Game state set to:', gameState);
            
            document.getElementById('instructions').style.display = 'block';
            console.log('Instructions displayed');
            
            // Start background music
            playBackgroundMusic();

            player = createCharacter(CONFIG.CHARACTER.giColor, false, false); // Player has no belt
            console.log('Player character created');
            
            // Use the calculated ground level for initial position - player on left
            player.position.set(CONFIG.ARENA.playerStartX, CONFIG.CHARACTER.legLowerLength / 2, 0);
            console.log('Player positioned at:', player.position.x, player.position.y, player.position.z);
            
            // Preserve the limb references by merging the initial state into the existing userData
            Object.assign(player.userData, initialPlayerState);
            console.log('Player state initialized with textures:', 
                        'Standing:', !!player.userData.standingTexture, 
                        'Kick frames:', player.userData.kickTextures ? player.userData.kickTextures.length : 0);
            
            scene.add(player);

            opponent = createCharacter(CONFIG.CHARACTER.opponentGiColor, true, true); // Opponent has belt and is flipped
            console.log('Opponent character created');
            
            // Use the calculated ground level for initial position - opponent on right
            opponent.position.set(CONFIG.ARENA.opponentStartX, CONFIG.CHARACTER.legLowerLength / 2, 0);
            console.log('Opponent positioned at:', opponent.position.x, opponent.position.y, opponent.position.z);
            
            // Preserve the limb references by merging the initial state into the existing userData
            Object.assign(opponent.userData, initialOpponentState);
            console.log('Opponent state initialized with textures:', 
                        'Standing:', !!opponent.userData.standingTexture, 
                        'Kick frames:', opponent.userData.kickTextures ? opponent.userData.kickTextures.length : 0);
                        
            opponent.userData.nextMoveTime = clock.getElapsedTime() + Math.random() * (CONFIG.AI.moveIntervalMax - CONFIG.AI.moveIntervalMin) / 1000 + CONFIG.AI.moveIntervalMin / 1000;
            opponent.userData.nextAttackTime = clock.getElapsedTime() + Math.random() * (CONFIG.AI.attackIntervalMax - CONFIG.AI.attackIntervalMin) / 1000 + CONFIG.AI.attackIntervalMin / 1000;
            scene.add(opponent);

            // Create HTML-based health bars instead of Three.js objects
            createHTMLHealthBars();

            keysPressed = {};
            activeMobileInputs = {};
            Object.values(mobileButtons).forEach(btn => { btn.visible = true; });
            positionMobileControls();
        }

        function setupEnding() {
            clearScene();
            
            // Hide health bars
            document.getElementById('player-health-bar').style.display = 'none';
            document.getElementById('opponent-health-bar').style.display = 'none';
            
            // Stop background music
            stopBackgroundMusic();
            // Remove any existing HTML buttons
            const startFightButton = document.getElementById('startFightButton');
            if (startFightButton) {
                startFightButton.parentNode.removeChild(startFightButton);
            }
            const existingPlayAgainButton = document.getElementById('playAgainButton');
            if (existingPlayAgainButton) {
                existingPlayAgainButton.parentNode.removeChild(existingPlayAgainButton);
            }
            
            gameState = 'ending';
            Object.values(mobileButtons).forEach(btn => { btn.visible = false; });

            player = createCharacter(CONFIG.CHARACTER.giColor, true);
            player.position.set(0, 0.75, 0);
            player.userData.victoryAnim = { raising: true, armRotation: 0, holding: false, holdTimer: 0 };
            scene.add(player);

            const endLines = [
                "Victory!", "To Be Continued at", "Evelyn's Birthday Party!", "",
                "Join us at UMAC Briarcliff", "528 N State Rd", 
                "Briarcliff Manor, NY 10510",
                 "April 26, 2025 @ 1:00 PM", // *** EXAMPLE PARTY TIME ***
            ];
            endText = createTextMesh(endLines.join('\n'), { x: 0, y: 3, z: 0 }, 0.7, true); // Adjusted scale/pos
            endText.material.opacity = 0;
            scene.add(endText);

            // Create a clickable HTML button for Play Again
            const playAgainButtonHTML = document.createElement('button');
            playAgainButtonHTML.id = 'playAgainButton'; // Add ID for easier selection
            playAgainButtonHTML.textContent = 'Play Again';
            playAgainButtonHTML.style.position = 'absolute';
            playAgainButtonHTML.style.left = '50%';
            playAgainButtonHTML.style.top = '80%';
            playAgainButtonHTML.style.transform = 'translate(-50%, -50%)';
            playAgainButtonHTML.style.padding = '15px 30px';
            playAgainButtonHTML.style.fontSize = '24px';
            playAgainButtonHTML.style.backgroundColor = '#00ff00';
            playAgainButtonHTML.style.color = 'white';
            playAgainButtonHTML.style.border = 'none';
            playAgainButtonHTML.style.borderRadius = '5px';
            playAgainButtonHTML.style.cursor = 'pointer';
            playAgainButtonHTML.style.fontFamily = 'Arial, sans-serif';
            playAgainButtonHTML.style.fontWeight = 'bold';
            playAgainButtonHTML.style.zIndex = '1000';
            playAgainButtonHTML.onclick = function() {
                // Remove the button immediately when clicked
                if (playAgainButtonHTML.parentNode) {
                    playAgainButtonHTML.parentNode.removeChild(playAgainButtonHTML);
                }
                startGameplay();
            };
            document.body.appendChild(playAgainButtonHTML);
            
            // Store reference - use let instead of const for playAgainButton in the global variables
            playAgainButton = playAgainButtonHTML;

            createConfetti();

            player.userData.endFadeInTimer = clock.getElapsedTime() + 0.5;
        }

        // --- Asset Creation (Mostly unchanged, ensure materials allow transparency where needed) ---
        function createCharacter(giColor, hasBelt, isOpponent = false) {
            const group = new THREE.Group();
            
            // Set character ID
            group.userData.id = isOpponent ? 'opponent' : 'player';
            console.log(`Creating character: ${group.userData.id}`);
            
            // Load textures
            const textureLoader = new THREE.TextureLoader();
            const standingTexture = textureLoader.load('evelyn-standing.png', texture => {
                // Create a canvas to extract pixel data for collision detection
                extractTextureData(texture, 'standing');
            });
            
            // Preload all kick frames (0001-0010)
            const kickTextures = [];
            for (let i = 1; i <= 10; i++) {
                const num = i.toString().padStart(3, '0');
                const texture = textureLoader.load(`evelyn-kick-${num}.png`, texture => {
                    // Create a canvas to extract pixel data for collision detection
                    extractTextureData(texture, `kick-${num}`);
                });
                kickTextures.push(texture);
            }
            
            // Preload jump frames
            const jumpTextures = [
                textureLoader.load('evelyn-jump-001.png', texture => {
                    // Create a canvas to extract pixel data for collision detection
                    extractTextureData(texture, 'jump-001');
                }),
                textureLoader.load('evelyn-jump-002.png', texture => {
                    // Create a canvas to extract pixel data for collision detection
                    extractTextureData(texture, 'jump-002');
                })
            ];
            
            // Create sprite with proper aspect ratio
            const aspectRatio = 2285/2428;
            const planeGeometry = new THREE.PlaneGeometry(aspectRatio * 5.5, 5.5);
            const planeMaterial = new THREE.MeshBasicMaterial({
                map: standingTexture,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.position.y = 0.0;
            
            // If this is the opponent, flip horizontally by scaling negative on X axis
            if (isOpponent) {
                plane.scale.x = -1; // This flips the sprite horizontally
            }
            
            group.add(plane);
            
            // Store animation data
            group.userData = {
                body: plane,
                standingTexture: standingTexture,
                kickTextures: kickTextures,
                jumpTextures: jumpTextures,
                isKicking: false,
                isJumping: false,
                currentKickFrame: 0,
                currentJumpFrame: 0,
                kickTimer: 0
            };
            
            return group;
        }

        function createTextMesh(text, position, scale = 1, transparent = true, centerAlign = true) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const lines = text.split('\n');
            const fontSize = 32 * window.devicePixelRatio; // Adjust for device pixel ratio
            context.font = CONFIG.UI.font.replace(/\d+px/, fontSize + 'px');

            let maxWidth = 0;
            lines.forEach(line => { maxWidth = Math.max(maxWidth, context.measureText(line).width); });
            const lineHeight = fontSize * 1.2;
            canvas.width = THREE.MathUtils.ceilPowerOfTwo(maxWidth + 20 * window.devicePixelRatio);
            canvas.height = THREE.MathUtils.ceilPowerOfTwo(lines.length * lineHeight + 10 * window.devicePixelRatio);

            context.font = CONFIG.UI.font.replace(/\d+px/, fontSize + 'px'); // Re-apply font after resize
            context.fillStyle = CONFIG.UI.fontColor;
            context.strokeStyle = CONFIG.UI.outlineColor;
            context.lineWidth = 4 * window.devicePixelRatio;
            context.textAlign = centerAlign ? 'center' : 'left';
            context.textBaseline = 'middle'; // Adjust baseline for better centering

            const startX = centerAlign ? canvas.width / 2 : 10 * window.devicePixelRatio;
            const startY = canvas.height / 2 - (lines.length - 1) * lineHeight / 2; // Center vertically

            lines.forEach((line, index) => {
                const yPos = startY + index * lineHeight;
                context.strokeText(line, startX, yPos);
                context.fillText(line, startX, yPos);
            });

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            texture.minFilter = THREE.LinearFilter; // Nicer scaling

            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: transparent,
                opacity: transparent ? 0 : 1,
                depthTest: false, // Render text on top
                depthWrite: false,
            });

            const planeWidth = canvas.width / (150 / scale); // Adjust scaling base
            const planeHeight = canvas.height / (150 / scale);
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(position.x, position.y, position.z);
            mesh.renderOrder = 1; // Ensure text renders on top
            return mesh;
        }

        function createButtonMesh(text, color, position) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 48 * window.devicePixelRatio;
            const buttonPadding = 20 * window.devicePixelRatio;
            context.font = `bold ${fontSize}px Arial`;

            const textMetrics = context.measureText(text);
            const textWidth = textMetrics.width;
            canvas.width = THREE.MathUtils.ceilPowerOfTwo(textWidth + buttonPadding * 2);
            canvas.height = THREE.MathUtils.ceilPowerOfTwo(fontSize * 1.5);

            context.font = `bold ${fontSize}px Arial`; // Re-apply

            context.fillStyle = `rgba(${Math.floor(color >> 16 & 255)}, ${Math.floor(color >> 8 & 255)}, ${Math.floor(color & 255)}, ${0.7})`;
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.fillStyle = CONFIG.UI.fontColor;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true; texture.minFilter = THREE.LinearFilter;
            const geo = new THREE.PlaneGeometry(CONFIG.UI.buttonWidth, CONFIG.UI.buttonHeight);
            const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, depthTest: false, depthWrite: false });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(position.x, position.y, position.z);
            mesh.renderOrder = 1; // Ensure button renders on top
            return mesh;
        }

        function createHTMLHealthBars() {
            const playerHealthBar = document.getElementById('player-health-bar');
            const opponentHealthBar = document.getElementById('opponent-health-bar');

            // Show the health bars during gameplay
            playerHealthBar.style.display = 'block';
            opponentHealthBar.style.display = 'block';

            // Reset health bar fills to full
            const playerHealthBarFill = document.getElementById('player-health-bar-fill');
            playerHealthBarFill.style.width = '100%';
            playerHealthBarFill.style.transform = 'scaleX(1)';

            const opponentHealthBarFill = document.getElementById('opponent-health-bar-fill');
            opponentHealthBarFill.style.width = '100%';
            opponentHealthBarFill.style.transform = 'scaleX(1)';
        }

        function updateHealthBar(isPlayer, currentHealth) {
            const healthBar = isPlayer ? document.getElementById('player-health-bar-fill') : document.getElementById('opponent-health-bar-fill');
            const healthPercentage = Math.max(0, currentHealth / CONFIG.HEALTH.max);
            
            // For both bars, we'll use transform to scale them properly from the correct edge
            healthBar.style.transform = `scaleX(${healthPercentage})`;
        }

        function createMobileControls() {
            const buttonSize = CONFIG.UI.mobileButtonSize;
            const opacity = CONFIG.UI.mobileButtonOpacity;

            const createButton = (color, name, icon) => {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = `rgba(${Math.floor(color >> 16 & 255)}, ${Math.floor(color >> 8 & 255)}, ${Math.floor(color & 255)}, ${opacity})`;
                ctx.beginPath(); ctx.arc(32, 32, 30, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = 'white'; ctx.strokeStyle = 'black'; ctx.lineWidth = 3;
                if (icon === 'left') { ctx.beginPath(); ctx.moveTo(45, 15); ctx.lineTo(19, 32); ctx.lineTo(45, 49); ctx.stroke(); ctx.fill(); }
                else if (icon === 'right') { ctx.beginPath(); ctx.moveTo(19, 15); ctx.lineTo(45, 32); ctx.lineTo(19, 49); ctx.stroke(); ctx.fill(); }
                else if (icon === 'up') { ctx.beginPath(); ctx.moveTo(32, 15); ctx.lineTo(47, 30); ctx.lineTo(37, 30); ctx.lineTo(37, 49); ctx.lineTo(27, 49); ctx.lineTo(27, 30); ctx.lineTo(17, 30); ctx.closePath(); ctx.stroke(); ctx.fill(); }
                else if (icon === 'attack') { ctx.beginPath(); for (let i = 0; i < 8; i++) { const angle = (i / 8) * Math.PI * 2; const radius = (i % 2 === 0) ? 20 : 15; ctx.lineTo(32 + Math.cos(angle) * radius, 32 + Math.sin(angle) * radius); } ctx.closePath(); ctx.stroke(); ctx.fill(); }

                const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true; texture.minFilter = THREE.LinearFilter;
                const geo = new THREE.PlaneGeometry(buttonSize, buttonSize);
                // Use MeshBasicMaterial, depthTest: false to ensure they are drawn on top and don't interact with scene depth
                const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 1, depthTest: false, depthWrite: false });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.visible = false;
                mesh.userData.action = name;
                mesh.renderOrder = 2; // Render mobile controls above everything else
                camera.add(mesh); // Add to camera
                return mesh;
            };

            mobileButtons.left = createButton(CONFIG.COLORS.mobileLeftRight, 'moveLeft', 'left');
            mobileButtons.right = createButton(CONFIG.COLORS.mobileLeftRight, 'moveRight', 'right');
            mobileButtons.jump = createButton(CONFIG.COLORS.mobileJump, 'jump', 'up');
            mobileButtons.punch = createButton(CONFIG.COLORS.mobilePunch, 'attackPunch', 'attack');
            mobileButtons.kick = createButton(CONFIG.COLORS.mobileKick, 'attackKick', 'attack');
            positionMobileControls(); // Set initial positions
        }

        function positionMobileControls() {
            if(!mobileButtons.left) return; // Don't position if not created yet

            const H = window.innerHeight;
            const W = window.innerWidth;
            // Position based on viewport size using NDC-like values relative to camera
             const scaleFactor = Math.min(W, H) / 500; // Adjust base size for different screens
             const btnSize = CONFIG.UI.mobileButtonSize * scaleFactor;
             const margin = 0.15 * scaleFactor; // Margin scaled too

             Object.values(mobileButtons).forEach(btn => {btn.scale.set(scaleFactor, scaleFactor, 1)});

            // Use view coordinates (relative to camera)
            const aspect = W / H;
            const viewHeight = 4; // Adjust this based on camera FOV and distance if needed
            const viewWidth = viewHeight * aspect;
            const camZOffset = -3; // Push slightly further away

            // Positioning logic (bottom corners)
            const bottomY = -viewHeight / 2 + margin + btnSize / 2;
            const leftX = -viewWidth / 2 + margin + btnSize / 2;
            const rightX = viewWidth / 2 - margin - btnSize / 2;

            mobileButtons.left.position.set(leftX, bottomY, camZOffset);
            mobileButtons.right.position.set(leftX + btnSize + margin*0.5, bottomY, camZOffset); // Next to left

            mobileButtons.punch.position.set(rightX, bottomY, camZOffset);
            mobileButtons.kick.position.set(rightX - btnSize - margin*0.5, bottomY, camZOffset); // Next to punch

            // Ensure buttons added to camera are correctly oriented (only needed if camera moves/rotates significantly)
            // Object.values(mobileButtons).forEach(btn => btn.lookAt(camera.position)); // Usually not needed if camera is static
        }

        function createConfetti() {
            // First make sure any existing confetti is cleared
            confetti.forEach(confetto => {
                scene.remove(confetto);
                if (confetto.geometry) confetto.geometry.dispose();
                if (confetto.material) confetto.material.dispose();
            });
            confetti = [];
            
            // Remove any existing confetti group
            const existingConfettiGroup = scene.getObjectByName('confettiGroup');
            if (existingConfettiGroup) {
                scene.remove(existingConfettiGroup);
            }
            
            // Create new confetti
            const confettiGroup = new THREE.Group();
            confettiGroup.name = 'confettiGroup';
            const confettiGeo = new THREE.SphereGeometry(0.05, 6, 6);

            for (let i = 0; i < CONFIG.CONFETTI.count; i++) {
                const confettiMat = new THREE.MeshBasicMaterial({ color: CONFIG.CONFETTI.colors[Math.floor(Math.random() * CONFIG.CONFETTI.colors.length)] });
                const particle = new THREE.Mesh(confettiGeo, confettiMat);
                particle.position.set(
                    (Math.random() - 0.5) * CONFIG.ARENA.width * 0.8,
                    CONFIG.CONFETTI.spawnY + (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                particle.userData.velocity = new THREE.Vector3(
                     (Math.random() - 0.5) * 0.01,
                     -CONFIG.CONFETTI.fallSpeed * (0.8 + Math.random() * 0.4),
                     (Math.random() - 0.5) * 0.01
                 );
                confettiGroup.add(particle);
                confetti.push(particle);
            }
            scene.add(confettiGroup);
            console.log('Created new confetti:', confetti.length, 'particles');
        }

        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            positionMobileControls();
        }

        function onKeyDown(event) {
            keysPressed[event.code] = true;
            
            // Only process gameplay inputs during gameplay state
            if (gameState === 'gameplay') {
                if (event.code === 'Space') { 
                    event.preventDefault(); 
                    handleAttackInput('player'); 
                }
                if (event.code === 'ArrowUp') { 
                    event.preventDefault(); 
                    handleJumpInput('player'); 
                }
            }
        }

        function onKeyUp(event) {
            keysPressed[event.code] = false;
        }

        // --- Pointer (Mouse/Touch) Handlers ---
        function handlePointerInteraction(event, isDown) {
             // Calculate pointer position in normalized device coordinates (-1 to +1)
             pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
             pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

             // Raycast against UI buttons attached to camera
             raycaster.setFromCamera(pointer, camera);
             const intersectsUI = raycaster.intersectObjects(Object.values(mobileButtons));

             if (intersectsUI.length > 0) {
                 const button = intersectsUI[0].object;
                 const action = button.userData.action;

                 if (isDown) {
                     activeMobileInputs[event.pointerId] = action; // Track which button this pointer pressed
                     if (action === 'moveLeft') keysPressed['MobileLeft'] = true;
                     else if (action === 'moveRight') keysPressed['MobileRight'] = true;
                     else if (action === 'jump') handleJumpInput('player');
                     else if (action === 'attackPunch' || action === 'attackKick') handleAttackInput('player', action === 'attackPunch' ? 'punch' : 'kick');
                 }
                 return true; // Indicate UI interaction happened
             }

             // Raycast against scene objects (Start/Play Again) only on pointer down
            if (isDown) {
                // Use the same raycaster that's already set up with the pointer position
                if (gameState === 'intro' && startButton) {
                    // For menu buttons, we need to check recursively to handle button meshes properly
                    const intersectsScene = raycaster.intersectObject(startButton, true);
                    if (intersectsScene.length > 0) {
                        startGameplay(); 
                        return true;
                    }
                } else if (gameState === 'ending' && playAgainButton) {
                    const intersectsScene = raycaster.intersectObject(playAgainButton, true);
                     if (intersectsScene.length > 0) {
                         startGameplay(); 
                         return true;
                     }
                }
            }
             return false; // No UI interaction
         }

        function onPointerDown(event) {
            event.preventDefault();
            handlePointerInteraction(event, true);
        }

        function onPointerUp(event) {
             event.preventDefault();
             const releasedAction = activeMobileInputs[event.pointerId];
             if (releasedAction === 'moveLeft') keysPressed['MobileLeft'] = false;
             if (releasedAction === 'moveRight') keysPressed['MobileRight'] = false;
             delete activeMobileInputs[event.pointerId]; // Clear tracked input

             // Might need to check if *any* pointer is still down on a move button
             // This simple version assumes one touch per button type at a time
             let stillMovingLeft = false;
             let stillMovingRight = false;
             for (const id in activeMobileInputs) {
                 if (activeMobileInputs[id] === 'moveLeft') stillMovingLeft = true;
                 if (activeMobileInputs[id] === 'moveRight') stillMovingRight = true;
             }
             if (!stillMovingLeft) keysPressed['MobileLeft'] = false;
             if (!stillMovingRight) keysPressed['MobileRight'] = false;
        }

        function onPointerMove(event) {
            // If a pointer moves off its button, treat it as pointer up for that button
            event.preventDefault();
             if (!activeMobileInputs[event.pointerId]) return; // Only care if this pointer was down on a button

             pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
             pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
             raycaster.setFromCamera(pointer, camera);
             const intersectsUI = raycaster.intersectObjects(Object.values(mobileButtons));

             let stillOnButton = false;
             if (intersectsUI.length > 0) {
                 if(intersectsUI[0].object.userData.action === activeMobileInputs[event.pointerId]) {
                    stillOnButton = true;
                 }
             }

             if (!stillOnButton) {
                // Moved off the button, trigger release for that action
                const releasedAction = activeMobileInputs[event.pointerId];
                if (releasedAction === 'moveLeft') keysPressed['MobileLeft'] = false;
                if (releasedAction === 'moveRight') keysPressed['MobileRight'] = false;
                 delete activeMobileInputs[event.pointerId];

                 // Re-check if any *other* pointer is still holding move buttons
                 // (Same logic as onPointerUp)
                 let stillMovingLeft = false;
                 let stillMovingRight = false;
                 for (const id in activeMobileInputs) {
                     if (activeMobileInputs[id] === 'moveLeft') stillMovingLeft = true;
                     if (activeMobileInputs[id] === 'moveRight') stillMovingRight = true;
                 }
                 if (!stillMovingLeft) keysPressed['MobileLeft'] = false;
                 if (!stillMovingRight) keysPressed['MobileRight'] = false;
             }
        }

        function onPointerLeave(event) {
             // Treat leaving the canvas like pointer up for all active inputs from that pointer
             event.preventDefault();
             onPointerUp(event); // Simulate pointer up
        }

        // --- Input Processing ---
        function handleJumpInput(characterId) {
            const char = (characterId === 'player') ? player : opponent;
            if (!char || !char.userData) return;
            
            if (!char.userData.jumping && gameState === 'gameplay') {
                char.userData.jumping = true;
                char.userData.velocityY = CONFIG.MOVEMENT.jumpVelocity;
                // Set initial jump frame
                char.userData.body.material.map = char.userData.jumpTextures[0];
                char.userData.body.material.needsUpdate = true;
            }
        }

        function handleAttackInput(characterId, attackType) {
            const char = (characterId === 'player') ? player : opponent;
            if (!char || !char.userData) {
                console.log(`Attack input failed: invalid character ${characterId}`);
                return; // Guard
            }
            const now = clock.getElapsedTime();
            
            console.log(`Attack input for ${characterId}: currentState=${gameState}, isKicking=${char.userData.isKicking}, currentKickFrame=${char.userData.currentKickFrame}, cooldown=${((now - char.userData.lastAttackTime) * 1000).toFixed(0)}ms`);

            // Ensure we can attack if not currently kicking, regardless of attacking state
            // This fixes the issue where attacking state might be out of sync
            if ((!char.userData.isKicking || char.userData.currentKickFrame >= char.userData.kickTextures.length - 1) && 
                gameState === 'gameplay' && (now - char.userData.lastAttackTime > CONFIG.ATTACK.cooldown / 1000)) {
                
                // Reset hit flag for new attack
                char.userData.hitThisAttack = false;
                char.userData.attacking = true;
                
                // Use specified attack type if provided, otherwise alternate
                if (attackType) {
                    char.userData.attackType = attackType;
                } else if (characterId === 'player') {
                   char.userData.attackType = (char.userData.attackType === 'punch') ? 'kick' : 'punch';
                } else {
                    char.userData.attackType = (Math.random() < 0.5) ? 'punch' : 'kick'; // AI random attack
                }
                
                console.log(`${characterId} starting attack: ${char.userData.attackType}`);
                
                // For kick attacks, also set isKicking for animation
                if (char.userData.attackType === 'kick') {
                    // Force reset any previous kick animation
                    char.userData.isKicking = true;
                    char.userData.kickTimer = 0;
                    char.userData.currentKickFrame = 0;
                    
                    // Set first frame immediately
                    char.userData.body.material.map = char.userData.kickTextures[0];
                    char.userData.body.material.needsUpdate = true;
                    console.log(`${characterId} starting kick animation with texture: kick-001`);
                }
                
                char.userData.attackTimer = (char.userData.attackType === 'punch') ? 
                    CONFIG.ATTACK.punchDuration : CONFIG.ATTACK.kickDuration;
                char.userData.lastAttackTime = now;
            } else {
                console.log(`Attack input rejected: ${!char.userData.isKicking ? '' : 'still kicking, '} ${gameState !== 'gameplay' ? 'not in gameplay, ' : ''} ${(now - char.userData.lastAttackTime <= CONFIG.ATTACK.cooldown / 1000) ? 'cooldown active' : ''}`);
            }
        }

        // --- Game Logic ---
         function updatePlayer(deltaTime) {
             if (gameState !== 'gameplay' || !player) return;
            
            let moveDirection = 0;
            if (keysPressed['ArrowLeft']) moveDirection -= 1;
            if (keysPressed['ArrowRight']) moveDirection += 1;
            if (activeMobileInputs['left']) moveDirection -= 1;
            if (activeMobileInputs['right']) moveDirection += 1;
            
            if (moveDirection !== 0 && !player.userData.attacking) {
                const newX = player.position.x + moveDirection * CONFIG.MOVEMENT.speed;
                
                // Check boundaries
                if (newX - CHARACTER_HALF_WIDTH > SCREEN_LEFT && 
                    newX + CHARACTER_HALF_WIDTH < SCREEN_RIGHT) {
                    
                    // Check collision with opponent
                    if (opponent) {
                        const minDistance = CHARACTER_HALF_WIDTH * 1.5; // Minimum distance between characters
                        const potentialDistance = Math.abs(newX - opponent.position.x);
                        
                        if (potentialDistance < minDistance) {
                            console.log(`Collision prevented: player and opponent would be too close (${potentialDistance.toFixed(2)} < ${minDistance.toFixed(2)})`);
                            // Position player at the maximum allowed distance
                            if (newX < opponent.position.x) {
                                // Player is to the left of opponent
                                player.position.x = opponent.position.x - minDistance;
                            } else {
                                // Player is to the right of opponent
                                player.position.x = opponent.position.x + minDistance;
                            }
                        } else {
                            player.position.x = newX;
                        }
                    } else {
                        player.position.x = newX;
                    }
                }
            }
            
            // Handle jumping physics
            if (player.userData.jumping) {
                // Apply gravity (scale with deltaTime for consistent behavior)
                player.userData.velocityY -= CONFIG.MOVEMENT.gravity * deltaTime * 60;
                
                // Update vertical position
                const newY = player.position.y + player.userData.velocityY;
                
                // Enforce maximum jump height
                if (newY > CONFIG.MOVEMENT.maxJumpHeight) {
                    player.position.y = CONFIG.MOVEMENT.maxJumpHeight;
                    player.userData.velocityY = 0; // Start falling
                } else if (newY <= CONFIG.CHARACTER.legLowerLength / 2) {
                    // Ground collision - ensure character is at proper floor level
                    player.position.y = CONFIG.CHARACTER.legLowerLength / 2;
                    player.userData.jumping = false;
                    player.userData.velocityY = 0;
                    
                    // Explicitly reset to standing texture on landing
                    player.userData.body.material.map = player.userData.standingTexture;
                    player.userData.body.material.needsUpdate = true;
                } else {
                    player.position.y = newY;
                }
            }
            
            // Attack handling
            if (player.userData.attacking) {
                player.userData.attackTimer -= deltaTime * 1000;
                if (player.userData.attackTimer <= 0) {
                    player.userData.attacking = false;
                    // Check for hits
                    if (opponent) checkAttackHit(player, opponent);
                }
            }
            
            // Always ensure attacking state is false when not kicking
            if (!player.userData.isKicking && player.userData.attacking) {
                player.userData.attacking = false;
            }
            
            updateHealthBar(true, player.userData.health);
        }

        function updateOpponent(deltaTime) {
            if (gameState !== 'gameplay' || !opponent) return;
            
            const now = clock.getElapsedTime();
            if (now > opponent.userData.nextMoveTime && !opponent.userData.attacking) {
                opponent.userData.moveDirection = (Math.random() < 0.5) ? -1 : 1;
                opponent.userData.nextMoveTime = now + Math.random() * (CONFIG.AI.moveIntervalMax - CONFIG.AI.moveIntervalMin) / 1000 + CONFIG.AI.moveIntervalMin / 1000;
            }
            
            // Calculate potential new position
            const newX = opponent.position.x + opponent.userData.moveDirection * CONFIG.MOVEMENT.speed * 0.7;
            
            // Check boundaries
            if (newX - CHARACTER_HALF_WIDTH > SCREEN_LEFT && 
                newX + CHARACTER_HALF_WIDTH < SCREEN_RIGHT) {
                
                // Check if this would cause collision with player
                let canMove = true;
                if (player) {
                    const minDistance = CHARACTER_HALF_WIDTH * 1.5; // Minimum distance between characters
                    const potentialDistance = Math.abs(newX - player.position.x);
                    
                    if (potentialDistance < minDistance) {
                        console.log(`Opponent collision prevented: would be too close to player (${potentialDistance.toFixed(2)} < ${minDistance.toFixed(2)})`);
                        canMove = false;
                        
                        // Position opponent at the maximum allowed distance
                        if (newX < player.position.x) {
                            // Opponent is to the left of player
                            opponent.position.x = player.position.x - minDistance;
                        } else {
                            // Opponent is to the right of player
                            opponent.position.x = player.position.x + minDistance;
                        }
                        
                        // Reverse direction when blocked by player
                        opponent.userData.moveDirection *= -1;
                    }
                }
                
                if (canMove) {
                    opponent.position.x = newX;
                }
            } else {
                // Reverse direction if hitting boundary
                opponent.userData.moveDirection *= -1;
            }
            
            // AI Attacks
            if (now > opponent.userData.nextAttackTime && !opponent.userData.attacking) {
                opponent.userData.attacking = true;
                opponent.userData.attackType = (Math.random() < 0.5) ? 'punch' : 'kick';
                opponent.userData.attackTimer = (opponent.userData.attackType === 'punch') ? 
                    CONFIG.ATTACK.punchDuration : CONFIG.ATTACK.kickDuration;
                opponent.userData.nextAttackTime = now + Math.random() * (CONFIG.AI.attackIntervalMax - CONFIG.AI.attackIntervalMin) / 1000 + CONFIG.AI.attackIntervalMin / 1000;
            }
            
            if (opponent.userData.attacking) {
                opponent.userData.attackTimer -= deltaTime * 1000;
                if (opponent.userData.attackTimer <= 0) {
                    opponent.userData.attacking = false;
                    if (player) checkAttackHit(opponent, player);
                }
            }
            
            // Always ensure attacking state is false when not kicking
            if (!opponent.userData.isKicking && opponent.userData.attacking) {
                opponent.userData.attacking = false;
            }
            
            updateHealthBar(false, opponent.userData.health);
        }

        function checkAttackHit(attacker, target) {
            // For kicks, we check during the kick animation, not just when attacking flag is set
            if (!attacker || !target || !attacker.userData || !target.userData || 
                (!attacker.userData.attacking && !attacker.userData.isKicking)) {
                return;
            }

            const attackType = attacker.userData.attackType;
            const damage = (attackType === 'punch') ? CONFIG.ATTACK.punchDamage : CONFIG.ATTACK.kickDamage;

            // First check if they're close enough for a potential hit (optimization)
            const distance = attacker.position.distanceTo(target.position);
            const reach = (attackType === 'punch') ? CONFIG.ATTACK.punchReach : CONFIG.ATTACK.kickReach;
            
            console.log(`Attack check: ${attacker.userData.id} (${attackType}) -> ${target.userData.id}, distance: ${distance.toFixed(2)}, reach: ${reach}, already hit: ${attacker.userData.hitThisAttack}`);
            
            if (distance < reach && !attacker.userData.hitThisAttack) {
                console.log('Distance check passed, performing collision detection');
                
                // For kicks, check if we're in the right animation frames for a hit (frames 3-9 are the extended kick)
                let canHit = true;
                if (attackType === 'kick' && attacker.userData.isKicking) {
                    canHit = attacker.userData.currentKickFrame >= 3 && attacker.userData.currentKickFrame <= 9;
                    console.log(`Kick frame check: ${attacker.userData.currentKickFrame}, can hit: ${canHit}`);
                }
                
                if (canHit) {
                    // For debugging purposes, sometimes force a hit for testing
                    const forceHit = true; // Temporarily enable to test hit mechanics
                    
                    // Use pixel-based collision detection
                    if (detectPixelCollision(attacker, target) || forceHit) {
                        console.log('Pixel collision detected - registering hit!');
                        
                        // Hit detected!
                        target.userData.health -= damage;
                        target.userData.health = Math.max(0, target.userData.health);
                        attacker.userData.hitThisAttack = true; // Mark hit for this attack sequence
                        target.userData.lastHitTime = clock.getElapsedTime(); // Record hit time
                        
                        // Visual feedback for hit
                        showHitEffect(target);
                        
                        // Update health bar
                        updateHealthBar(target.userData.id === 'player', target.userData.health);

                        console.log(`${attacker.userData.id} hit ${target.userData.id} (${attackType}). ${target.userData.id} health: ${target.userData.health}`);

                        // Check for win/loss condition
                        if (target.userData.health <= 0) {
                            if(target.userData.id === 'opponent') {
                                console.log("Player wins!");
                                setupEnding();
                            } else {
                                console.log("Opponent wins! Restarting.");
                                // Optional: Add a specific 'Game Over' screen later
                                startGameplay(); // Simple restart for now
                            }
                        }
                    } else {
                        console.log('No pixel collision detected - attack missed');
                    }
                }
            }
        }

        // Visual feedback for hit detection
        function showHitEffect(target) {
            if (!target || !target.userData || !target.userData.body) return;
            
            // Flash the character red briefly
            const originalColor = target.userData.body.material.color.clone();
            target.userData.body.material.color.set(0xff0000); // Red
            target.userData.body.material.needsUpdate = true;
            
            // Reset color after a short delay
            setTimeout(() => {
                if (target && target.userData && target.userData.body) {
                    target.userData.body.material.color.copy(originalColor);
                    target.userData.body.material.needsUpdate = true;
                }
            }, 150); // 150ms flash
            
            // Log hit for debugging
            console.log(`HIT CONFIRMED on ${target.userData.id}! Current health: ${target.userData.health}`);
        }
        
        // --- Animations (Ensure check for character existence) ---
         function updateIntroAnimation(deltaTime) {
            const now = clock.getElapsedTime();

            // Text fade
            if (introText && player && player.userData) { // Ensure objects exist
                 if (introText.material.opacity < 1 && player.userData.introFadeInTimer && now >= player.userData.introFadeInTimer) {
                     introText.material.opacity = Math.min(1, introText.material.opacity + deltaTime / (CONFIG.ANIMATION.textFadeTime / 1000));
                     if (introText.material.opacity >= 1) player.userData.introHoldTimer = now + CONFIG.ANIMATION.introHoldTime / 1000;
                 } else if (introText.material.opacity > 0 && player.userData.introHoldTimer && now >= player.userData.introHoldTimer) {
                     introText.material.opacity = Math.max(0, introText.material.opacity - deltaTime / (CONFIG.ANIMATION.textFadeTime / 1000));
                 }
            }

            // Character Kick
            if (player && player.userData && player.userData.introAnim && player.userData.rightLegUpper) {
                const anim = player.userData.introAnim;
                const leg = player.userData.rightLegUpper;
                const kickSpeed = CONFIG.ANIMATION.introKickSpeed;
                const maxRotation = -Math.PI / 4;

                if (anim.kicking) {
                    leg.rotation.x = Math.max(maxRotation, leg.rotation.x - kickSpeed);
                    if (leg.rotation.x <= maxRotation) { anim.kicking = false; anim.returning = true; }
                } else if (anim.returning) {
                    leg.rotation.x = Math.min(0, leg.rotation.x + kickSpeed * 1.5);
                    if (leg.rotation.x >= 0) anim.returning = false; // Stop animation
                }
            }
        }

        function updateEndingAnimation(deltaTime) {
            const now = clock.getElapsedTime();

            // Text Fade
            if (endText && player && player.userData) { // Ensure objects exist
                if (endText.material.opacity < 1 && player.userData.endFadeInTimer && now >= player.userData.endFadeInTimer) {
                     endText.material.opacity = Math.min(1, endText.material.opacity + deltaTime / (CONFIG.ANIMATION.textFadeTime / 1000));
                }
            }

            // Victory Pose
            if (player && player.userData && player.userData.victoryAnim && player.userData.leftArmUpper && player.userData.rightArmUpper) {
                const anim = player.userData.victoryAnim;
                const leftArm = player.userData.leftArmUpper;
                const rightArm = player.userData.rightArmUpper;
                const poseSpeed = CONFIG.ANIMATION.victoryPoseSpeed;
                const maxRotation = -Math.PI / 3; // Raise arms higher

                if (anim.raising) {
                     leftArm.rotation.x = Math.max(maxRotation, leftArm.rotation.x - poseSpeed);
                     rightArm.rotation.x = Math.max(maxRotation, rightArm.rotation.x - poseSpeed); // Match left arm logic
                     if (leftArm.rotation.x <= maxRotation) {
                         anim.raising = false; anim.holding = true; anim.holdTimer = now + 1.5; // Hold longer
                     }
                 } else if (anim.holding && now >= anim.holdTimer) {
                     anim.holding = false; anim.returning = true; // Add returning state
                 } else if (anim.returning) {
                     leftArm.rotation.x = Math.min(0, leftArm.rotation.x + poseSpeed * 1.5);
                     rightArm.rotation.x = Math.min(0, rightArm.rotation.x + poseSpeed * 1.5);
                     if (leftArm.rotation.x >= 0) {
                         anim.returning = false; // Stop returning
                         // Optional: restart anim.raising = true;
                     }
                 }
            }

            // Confetti - only update if in ending state
            if (gameState === 'ending') {
                confetti.forEach(particle => {
                    if (particle && particle.userData && particle.userData.velocity) {
                        particle.position.add(particle.userData.velocity);
                        particle.rotation.x += Math.random() * 0.1;
                        particle.rotation.y += Math.random() * 0.1;
                        if (particle.position.y < CONFIG.CONFETTI.despawnY) {
                            particle.position.set( (Math.random() - 0.5) * CONFIG.ARENA.width * 0.8, CONFIG.CONFETTI.spawnY + Math.random(), (Math.random() - 0.5) * 2 );
                            particle.userData.velocity.y = -CONFIG.CONFETTI.fallSpeed * (0.8 + Math.random() * 0.4);
                        }
                    }
                });
            }
         }

        function updateJumpAnimation(character, deltaTime) {
            if (!character || !character.userData || !character.userData.body) return;
            
            if (character.userData.jumping) {
                const body = character.userData.body;
                const jumpTextures = character.userData.jumpTextures;
                
                // Update frame based on vertical position and velocity
                if (character.position.y > 0.5) {
                    // In air - use second frame
                    body.material.map = jumpTextures[1];
                } else if (character.position.y > 0) { 
                    // Initial jump or landing - use first frame
                    body.material.map = jumpTextures[0];
                }
                // Note: We don't set standing texture here - it's handled in updatePlayer
                // when character actually lands (position.y <= 0)
                body.material.needsUpdate = true;
            } else if (character.position.y === CONFIG.CHARACTER.legLowerLength / 2) {
                // Safety check - ensure standing texture when on ground
                character.userData.body.material.map = character.userData.standingTexture;
                character.userData.body.material.needsUpdate = true;
            }
        }

        function updateKickAnimation(player, deltaTime) {
            if (!player || !player.userData || !player.userData.body) {
                return;
            }
            
            if (player.userData.isKicking) {
                player.userData.kickTimer += deltaTime;
                
                // Update frame every 50ms (20fps)
                if (player.userData.kickTimer >= 0.05) {
                    player.userData.kickTimer = 0;
                    player.userData.currentKickFrame++;
                    
                    console.log(`${player.userData.id} kick frame: ${player.userData.currentKickFrame}/${player.userData.kickTextures.length}`);
                    
                    if (player.userData.currentKickFrame < player.userData.kickTextures.length) {
                        // Show next frame
                        player.userData.body.material.map = 
                            player.userData.kickTextures[player.userData.currentKickFrame];
                        player.userData.body.material.needsUpdate = true;
                        
                        // Make sure attacking state stays true during kick animation
                        // This ensures hit detection works throughout the animation
                        player.userData.attacking = true;
                        
                        // Check for hits on frames where the kick is extended (frames 3-9)
                        if (player.userData.currentKickFrame >= 3 && player.userData.currentKickFrame <= 9) {
                            console.log(`${player.userData.id} checking for kick hit on frame ${player.userData.currentKickFrame}`);
                            // Check for hit against opponent
                            if (player.userData.id === 'player' && opponent) {
                                checkAttackHit(player, opponent);
                            } else if (player.userData.id === 'opponent' && player) {
                                // Note: player here is the opponent character, and the target is the player character
                                checkAttackHit(player, window.player);
                            }
                        }
                    } else {
                        // Animation complete
                        console.log(`${player.userData.id} kick animation complete`);
                        player.userData.isKicking = false;
                        player.userData.attacking = false; // Reset attacking state immediately
                        player.userData.body.material.map = player.userData.standingTexture;
                        player.userData.body.material.needsUpdate = true;
                    }
                }
            }
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            
            // Update billboarding for characters to always face camera
            scene.traverse(function(object) {
                if (object.userData && object.userData.isBillboard) {
                    object.quaternion.copy(camera.quaternion);
                }
            });

            // Always update animations regardless of game state if objects exist
            if (gameState === 'intro') updateIntroAnimation(deltaTime);
            if (gameState === 'ending') updateEndingAnimation(deltaTime);

            // Update kick animations - IMPORTANT: Process kick animations BEFORE jump animations
            if (player) updateKickAnimation(player, deltaTime);
            if (opponent) updateKickAnimation(opponent, deltaTime);
            
            // Update jump animations AFTER kick animations
            if (player && !player.userData.isKicking) updateJumpAnimation(player, deltaTime);
            if (opponent && !opponent.userData.isKicking) updateJumpAnimation(opponent, deltaTime);

            // Update gameplay logic only in gameplay state
            if (gameState === 'gameplay') {
                updatePlayer(deltaTime);
                updateOpponent(deltaTime);
            }

            renderer.render(scene, camera);
        }

        // --- Audio Functions ---
        function initAudio() {
            // Create audio element for background music
            backgroundMusic = new Audio('09. Ryu Stage.mp3');
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.7; // 70% volume
            
            // Add a click event listener to the document to enable audio
            // This helps with browsers that require user interaction
            document.addEventListener('click', function() {
                // This empty function just ensures we have user interaction
                // before trying to play any audio
            }, { once: true });
        }
        
        function playBackgroundMusic() {
            // Play background music if it exists
            if (backgroundMusic) {
                // Reset to beginning if it was already playing
                backgroundMusic.currentTime = 0;
                
                // Play the music with a user interaction (this is required by browsers)
                const playPromise = backgroundMusic.play();
                
                // Handle potential play() promise rejection
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.error('Audio playback failed:', error);
                    });
                }
                
                console.log('Background music started');
            }
        }
        
        function stopBackgroundMusic() {
            if (backgroundMusic && !backgroundMusic.paused) {
                backgroundMusic.pause();
                console.log('Background music stopped');
            }
        }
        
        // Extract pixel data from textures for collision detection
        function extractTextureData(texture, name) {
            // Wait for the image to load
            if (!texture.image || !texture.image.complete) {
                texture.addEventListener('load', function() {
                    extractTextureDataFromImage(texture.image, name);
                });
                return;
            }
            
            extractTextureDataFromImage(texture.image, name);
        }
        
        function extractTextureDataFromImage(image, name) {
            // Create a canvas to draw the image
            const canvas = document.createElement('canvas');
            canvas.width = image.width;
            canvas.height = image.height;
            
            // Draw the image onto the canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0);
            
            try {
                // Get the pixel data
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Count non-transparent pixels to verify texture data is valid
                let nonTransparentCount = 0;
                for (let i = 3; i < imageData.data.length; i += 4) {
                    if (imageData.data[i] > 50) nonTransparentCount++;
                }
                
                // Store the pixel data and dimensions
                texturePixelData[name] = {
                    data: imageData.data,
                    width: canvas.width,
                    height: canvas.height
                };
                
                console.log(`Extracted pixel data for texture: ${name}, dimensions: ${canvas.width}x${canvas.height}, non-transparent pixels: ${nonTransparentCount}`);
            } catch (e) {
                console.error(`Failed to extract pixel data for ${name}:`, e);
            }
        }
        
        // Detect pixel-level collision between two characters
        function detectPixelCollision(attacker, target) {
            // Get the current textures being used
            const attackerTexture = attacker.userData.body.material.map;
            const targetTexture = target.userData.body.material.map;
            
            if (!attackerTexture || !targetTexture) {
                console.log('Collision detection failed: missing textures');
                return false;
            }
            
            // Get the texture names
            let attackerTextureName = 'standing';
            let targetTextureName = 'standing';
            
            // Determine attacker texture name
            if (attacker.userData.isKicking) {
                attackerTextureName = `kick-${(attacker.userData.currentKickFrame + 1).toString().padStart(3, '0')}`;
            } else if (attacker.userData.isJumping) {
                attackerTextureName = `jump-${Math.min(attacker.userData.currentJumpFrame + 1, 2).toString().padStart(3, '0')}`;
            }
            
            // Determine target texture name
            if (target.userData.isKicking) {
                targetTextureName = `kick-${(target.userData.currentKickFrame + 1).toString().padStart(3, '0')}`;
            } else if (target.userData.isJumping) {
                targetTextureName = `jump-${Math.min(target.userData.currentJumpFrame + 1, 2).toString().padStart(3, '0')}`;
            }
            
            console.log(`Checking collision: ${attackerTextureName} vs ${targetTextureName}`);
            console.log('Available texture data keys:', Object.keys(texturePixelData));
            
            // Get pixel data
            let attackerData = texturePixelData[attackerTextureName];
            let targetData = texturePixelData[targetTextureName];
            
            if (!attackerData || !targetData) {
                console.log(`Collision detection failed: missing pixel data for ${!attackerData ? attackerTextureName : ''} ${!targetData ? targetTextureName : ''}`);
                
                // If we're missing data for the specific frame, fall back to standing texture
                if (!attackerData && attackerTextureName !== 'standing') {
                    console.log(`Trying fallback to standing texture for attacker`);
                    attackerData = texturePixelData['standing'];
                }
                if (!targetData && targetTextureName !== 'standing') {
                    console.log(`Trying fallback to standing texture for target`);
                    targetData = texturePixelData['standing'];
                }
                
                // If still no data, return false
                if (!attackerData || !targetData) {
                    return false;
                }
            }
            
            // Calculate character positions in world space
            const attackerWorldPos = new THREE.Vector3();
            const targetWorldPos = new THREE.Vector3();
            attacker.getWorldPosition(attackerWorldPos);
            target.getWorldPosition(targetWorldPos);
            
            // Calculate the overlap region between the two sprites
            // For simplicity, we'll use the character's size and position
            const attackerWidth = 1.0; // Character width in world units
            const attackerHeight = 2.0; // Character height in world units
            const targetWidth = 1.0;
            const targetHeight = 2.0;
            
            // Calculate world space boundaries
            const attackerLeft = attackerWorldPos.x - attackerWidth/2;
            const attackerRight = attackerWorldPos.x + attackerWidth/2;
            const attackerTop = attackerWorldPos.y + attackerHeight/2;
            const attackerBottom = attackerWorldPos.y - attackerHeight/2;
            
            const targetLeft = targetWorldPos.x - targetWidth/2;
            const targetRight = targetWorldPos.x + targetWidth/2;
            const targetTop = targetWorldPos.y + targetHeight/2;
            const targetBottom = targetWorldPos.y - targetHeight/2;
            
            console.log(`Attacker bounds: L=${attackerLeft.toFixed(2)}, R=${attackerRight.toFixed(2)}, T=${attackerTop.toFixed(2)}, B=${attackerBottom.toFixed(2)}`);
            console.log(`Target bounds: L=${targetLeft.toFixed(2)}, R=${targetRight.toFixed(2)}, T=${targetTop.toFixed(2)}, B=${targetBottom.toFixed(2)}`);
            
            // For kicks, use an extended bounding box to account for the kick reach
            let extendedAttackerRight = attackerRight;
            if (attacker.userData.isKicking && attacker.userData.currentKickFrame >= 3 && attacker.userData.currentKickFrame <= 9) {
                // Extend the attacker's bounding box in the direction they're facing
                const extendAmount = 1.5; // Extend by 1.5 units
                if (attacker.position.x < target.position.x) {
                    // Attacker is to the left of target, extend right
                    extendedAttackerRight = attackerRight + extendAmount;
                } else {
                    // Attacker is to the right of target, extend left
                    attackerLeft = attackerLeft - extendAmount;
                }
                console.log(`Extended kick bounding box: L=${attackerLeft.toFixed(2)}, R=${extendedAttackerRight.toFixed(2)}`);
            }
            
            // Check if bounding boxes overlap
            if (extendedAttackerRight < targetLeft || attackerLeft > targetRight || 
                attackerBottom > targetTop || attackerTop < targetBottom) {
                console.log('No bounding box overlap detected');
                return false; // No collision possible
            }
            
            console.log('Bounding boxes overlap, checking pixel collision');
            
            // Calculate overlap region
            const overlapLeft = Math.max(attackerLeft, targetLeft);
            const overlapRight = Math.min(attackerRight, targetRight);
            const overlapTop = Math.min(attackerTop, targetTop);
            const overlapBottom = Math.max(attackerBottom, targetBottom);
            
            console.log(`Overlap region: L=${overlapLeft.toFixed(2)}, R=${overlapRight.toFixed(2)}, T=${overlapTop.toFixed(2)}, B=${overlapBottom.toFixed(2)}`);
            
            // Convert world coordinates to texture coordinates
            const attackerTexLeft = Math.floor(((overlapLeft - attackerLeft) / attackerWidth) * attackerData.width);
            const attackerTexRight = Math.floor(((overlapRight - attackerLeft) / attackerWidth) * attackerData.width);
            const attackerTexTop = Math.floor(((attackerTop - overlapTop) / attackerHeight) * attackerData.height);
            const attackerTexBottom = Math.floor(((attackerTop - overlapBottom) / attackerHeight) * attackerData.height);
            
            const targetTexLeft = Math.floor(((overlapLeft - targetLeft) / targetWidth) * targetData.width);
            const targetTexRight = Math.floor(((overlapRight - targetLeft) / targetWidth) * targetData.width);
            const targetTexTop = Math.floor(((targetTop - overlapTop) / targetHeight) * targetData.height);
            const targetTexBottom = Math.floor(((targetTop - overlapBottom) / targetHeight) * targetData.height);
            
            console.log(`Attacker texture region: L=${attackerTexLeft}, R=${attackerTexRight}, T=${attackerTexTop}, B=${attackerTexBottom}`);
            console.log(`Target texture region: L=${targetTexLeft}, R=${targetTexRight}, T=${targetTexTop}, B=${targetTexBottom}`);
            
            // Sampling rate - check every few pixels for performance
            const samplingRate = 2; // Reduced from 4 to 2 for more accurate collision detection
            
            console.log(`Checking overlap region with dimensions: ${attackerTexRight-attackerTexLeft}x${attackerTexBottom-attackerTexTop}`);
            
            // Count non-transparent pixels to help diagnose issues
            let attackerNonTransparentCount = 0;
            let targetNonTransparentCount = 0;
            let overlappingPixelChecks = 0;
            
            // Check pixel collision in the overlap region
            for (let y = attackerTexTop; y < attackerTexBottom; y += samplingRate) {
                if (y < 0 || y >= attackerData.height) continue;
                
                const targetY = targetTexTop + (y - attackerTexTop);
                if (targetY < 0 || targetY >= targetData.height) continue;
                
                for (let x = attackerTexLeft; x < attackerTexRight; x += samplingRate) {
                    if (x < 0 || x >= attackerData.width) continue;
                    
                    const targetX = targetTexLeft + (x - attackerTexLeft);
                    if (targetX < 0 || targetX >= targetData.width) continue;
                    
                    overlappingPixelChecks++;
                    
                    // Get pixel indices
                    const attackerPixelIndex = (y * attackerData.width + x) * 4 + 3; // Alpha channel
                    const targetPixelIndex = (targetY * targetData.width + targetX) * 4 + 3; // Alpha channel
                    
                    // Count non-transparent pixels
                    if (attackerData.data[attackerPixelIndex] > 50) attackerNonTransparentCount++;
                    if (targetData.data[targetPixelIndex] > 50) targetNonTransparentCount++;
                    
                    // Check if both pixels are non-transparent (alpha > 0)
                    if (attackerData.data[attackerPixelIndex] > 50 && 
                        targetData.data[targetPixelIndex] > 50) {
                        console.log(`Pixel collision detected at attacker(${x},${y}) and target(${targetX},${targetY})`);
                        return true; // Collision detected!
                    }
                }
            }
            
            console.log(`Collision check stats: Checked ${overlappingPixelChecks} pixel pairs, ` +
                      `Attacker non-transparent: ${attackerNonTransparentCount}, ` +
                      `Target non-transparent: ${targetNonTransparentCount}`);
            
            
            console.log('No pixel collision detected');
            return false; // No collision
        }
        
        // --- Start ---
        init();
        
        // Debug log to confirm initialization
        console.log('Game initialized, waiting for gameplay to start');
    </script>
</body>
</html>